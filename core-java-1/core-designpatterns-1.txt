core java - design patterns

What is a design pattern?

-	A design pattern is a solution to recurring problem in a context.

-	There are three categories of design patterns, i.e. creational, structural and behavioral.

Explain and enlist creational design pattern?

-	The creational design pattern deals with process of creating objects of a class.

-	Below are different types of creational design patterns,

	-	Singleton
	
	-	Factory
	
Explain the singleton design pattern?

-	The singleton design pattern is a creational design pattern.

-	A singleton class has only one instance which can be accessed globally through one single point.

-	Any changes made to instance become visible globally.

-	It is often used to store application configurations.

Write a note on implementing singleton design pattern?

-	Restricting instance creation using private constructor and class inheritance using final keyword.

-	The singleton instance are referenced by static variable inside same singleton class.

-	To provide single point access to the static variable using static method.

-	A singleton class can be either eager or lazy.

-	In a eager singleton class instance is created when the class is loaded. In a lazy singleton class instance is created when it is required for the first time.

-	It requires synchronization and volatile to ensure multiple threads do not create multiple instance.

-	This implementation introduces double check locking problem, which can removed by using implementation with lazy initialization holder.  

Example:

public final class LazyRegistry {

	private LazyRegistry() {

	}

	public static LazyRegistry getInstance() {
		return Registry.INSTANCE;
	}

	private static class Registry {
		static volatile LazyRegistry INSTANCE = new LazyRegistry();
	}
}

public class Client {

	public static void main(String[] args) {
		System.out.print(LazyRegistry.getInstance() == LazyRegistry.getInstance());
	}
}

Write a note on design consideration for singleton design pattern?

-	The singleton instance creation must not depend on any parameter from client.

-	The global instance must not have too many mutable states.

Write a note on pitfalls of singleton design pattern?

-	Multiple part of code depend on one instance.

-	It is difficult to unit test.

-	The singleton instance are referenced by static variable which means one copy per class loader and not one copy per JVM.

-	The global instance with too many mutable states will introduce bugs.

Explain the prototype design pattern?

-	The prototype design pattern is a creational design pattern.

-	It is used when an creating instance of a class is costly.

-	An existing instance is used as a prototype and copies of it are created.

-	This saves instance creation from scratch.

Write a note on implementing prototype design pattern?

-	Creating an abstract prototype class which inherits the Cloneable interface.

-	Implementing the clone method as public to either return a shallow copy or deep copy.

-	The instance state is immutable then shallow cloning is recommended otherwise deep cloning is recommended.

-	Implementing the intialise method to reset state of cloned instance and not use exact state from prototype.

-	Inheriting the abstract prototype class.

Example:

public abstract class GameUnit implements Cloneable {

	protected Point3D position;

	public GameUnit() {
		this.position = Point3D.ZERO;
	}

	@Override
	public GameUnit clone() throws CloneNotSupportedException {
		GameUnit gameUnit = (GameUnit) super.clone();
		gameUnit.initialize();
		return gameUnit;
	}

	public void initialize() {
		this.position = Point3D.ZERO;
	}

	public void move(int x, int y, int z) {
		this.position = new Point3D(x, y, z);
	}
}

public class SwordsMan extends GameUnit {

	private boolean isAttacking;

	public SwordsMan() {
		this.isAttacking = false;
	}

	@Override
	public void initialize() {
		super.initialize();
		this.isAttacking = false;
	}

	public void attack() {
		this.isAttacking = true;
	}

	@Override
	public String toString() {
		return "SwordsMan isAttacking=" + isAttacking + " at position=" + position;
	}
}

public class Client {

	public static void main(String[] args) throws CloneNotSupportedException {
		SwordsMan prototype = new SwordsMan();
		prototype.move(-10, 0, 0);
		prototype.attack();
		System.out.println(prototype);

		SwordsMan swordsMan = (SwordsMan) prototype.clone();
		System.out.println(swordsMan);
	}
}

Write a note on design consideration for prototype design pattern?

-	The prototype design pattern must be used when majority states are unchanged between instances.

-	The prototype instance can be saved inside registry and accessed when required.

-	This design pattern is required to support composite and decorator design pattern.

Write a note on pitfalls of prototype design pattern?

-	An prototype instance with too many mutable states is complex to clone.

-	The default implementation of clone in Object class allows shallow cloning only and not deep cloning.

-	A child class may not allow cloning and throw a runtime exception CloneNotSupportedException.

Explain the builder design pattern?

-	The builder design pattern is a creational design pattern.

-	It is used when an creating instance of a class is complex because of constructor with too many arguements.

-	Also when an creating an instance of a class requires another class instance to exists.

Write a note on implementing builder design pattern?

-	Identifying too many data members of a class and define a complex constructor.

-	Creating an nested static builder class with methods to initialize parts of an instance.

-	Implementing build method to assemble an instance of the class. 

Example:

public class Person {

	private String firstName;
	private String lastName;
	private int age;
	private char gender;
	private String address;
	private String city;
	private String state;
	private String country;
	private long pincode;
	private String mobile;
	private String email;

	public Person(String firstName, String lastName, int age, char gender, String address, String city, String state,
			String country, long pincode, String mobile, String email) {
		this.firstName = firstName;
		this.lastName = lastName;
		this.age = age;
		this.gender = gender;
		this.address = address;
		this.city = city;
		this.state = state;
		this.country = country;
		this.pincode = pincode;
		this.mobile = mobile;
		this.email = email;
	}

	public static PersonBuilder getBuilder() {
		return new PersonBuilder();
	}
	
	@Override
	public String toString() {
		return "Person [firstName=" + firstName + ", lastName=" + lastName + ", age=" + age + ", gender=" + gender
				+ ", address=" + address + ", city=" + city + ", state=" + state + ", country=" + country + ", pincode="
				+ pincode + ", mobile=" + mobile + ", email=" + email + "]";
	}

	public static class PersonBuilder {

		private String firstName;
		private String lastName;
		private int age;
		private char gender;
		private String address;
		private String city;
		private String state;
		private String country;
		private long pincode;
		private String mobile;
		private String email;
		private Person person;

		public PersonBuilder withFirstName(String firstName) {
			this.firstName = firstName;
			return this;
		}

		public PersonBuilder withLastName(String lastName) {
			this.lastName = lastName;
			return this;
		}

		public PersonBuilder withAge(int age) {
			this.age = age;
			return this;
		}

		public PersonBuilder withGender(char gender) {
			this.gender = gender;
			return this;
		}

		public PersonBuilder withAddress(String address) {
			this.address = address;
			return this;
		}

		public PersonBuilder withCity(String city) {
			this.city = city;
			return this;
		}

		public PersonBuilder withState(String state) {
			this.state = state;
			return this;
		}

		public PersonBuilder withCountry(String country) {
			this.country = country;
			return null;
		}

		public PersonBuilder withPincode(long pincode) {
			this.pincode = pincode;
			return null;
		}

		public PersonBuilder withMobile(String mobile) {
			this.mobile = mobile;
			return this;
		}

		public PersonBuilder withEmail(String email) {
			this.email = email;
			return this;
		}

		public Person build() {
			this.person = new Person(firstName, lastName, age, gender, address, city, state, country, pincode, mobile, email);
			return person;
		}

		public Person getPerson() {
			return person;
		}
	}
}

public class Client {

	public static void main(String[] args) {
		Person person = Person.getBuilder().withFirstName("java").withLastName("hub").withAge(27)
				.withEmail("hubjava98@gmail.com").build();
		System.out.println(person);
	}
}

Write a note on design consideration for builder design pattern?

-	A nested static builder class provide decent namespace.

-	The builder design pattern must be used when too many constructor arguements exists.

Write a note on pitfalls of builder design pattern?

-	Method chaining can be difficult to understand.

-	Instance might be partially constructed.

Explain the simple factory design pattern?

-	The simple factory design pattern is a creational design pattern.

-	It encapsulates the logic for instance creation inside a separate static method.

-	It allows choice based instance creation.	

Write a note on implementing simple factory design pattern?

-	Implementing a factory class with static method.

Example:

public class Post {

	private String title;

	private String content;

	private LocalDateTime createdOn;

	private LocalDateTime publishedOn;

	public String getTitle() {
		return title;
	}

	public void setTitle(String title) {
		this.title = title;
	}

	public String getContent() {
		return content;
	}

	public void setContent(String content) {
		this.content = content;
	}

	public LocalDateTime getCreatedOn() {
		return createdOn;
	}

	public void setCreatedOn(LocalDateTime createdOn) {
		this.createdOn = createdOn;
	}

	public LocalDateTime getPublishedOn() {
		return publishedOn;
	}

	public void setPublishedOn(LocalDateTime publishedOn) {
		this.publishedOn = publishedOn;
	}
}

public class NewsPost extends Post {

	private String headline;

	private LocalDateTime newsTime;

	public String getHeadline() {
		return headline;
	}

	public void setHeadline(String headline) {
		this.headline = headline;
	}

	public LocalDateTime getNewsTime() {
		return newsTime;
	}

	public void setNewsTime(LocalDateTime newsTime) {
		this.newsTime = newsTime;
	}
}

public class BlogPost extends Post {

	private String author;

	private String[] tags;

	public String getAuthor() {
		return author;
	}

	public void setAuthor(String author) {
		this.author = author;
	}

	public String[] getTags() {
		return tags;
	}

	public void setTags(String[] tags) {
		this.tags = tags;
	}
}

public class ProductPost extends Post {

	private String name;

	private String imageUrl;

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public String getImageUrl() {
		return imageUrl;
	}

	public void setImageUrl(String imageUrl) {
		this.imageUrl = imageUrl;
	}
}

public class PostFactory {

	public static Post getPost(String type) {
		switch (type) {
		case "news":
			return new NewsPost();
		case "blog":
			return new BlogPost();
		case "product":
			return new ProductPost();
		default:
			throw new IllegalArgumentException("Post type is unknown");
		}
	}
}

Write a note on design consideration for simple factory design pattern?

-	A separate simple factory class is easy to access.

-	A static method is suitable as there is no need of any state tracking.

-	A simple factory class can use other design patterns to create instance of a class.

Write a note on pitfalls of simple factory design pattern?

-	More choices can cause more complex instance creation.