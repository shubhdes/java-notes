core java - design patterns

Explain and enlist behavioral design pattern?

-	The behavioral design pattern deal with how classes and objects interact or communicate with each other.

-	Below are different types of behavioral design patterns,

	-	chain of responsibility
	
	-	command
	
	-	interpreter
	
	-	mediator
	
	-	iterator
	
	-	memento
	
	-	observer
	
	-	state
	
	-	strategy
	
	-	template method
	
	-	visitor
	
	-	null object

Explain the chain of responsibility design pattern?

-	The chain of responsibility design pattern is a behavioral design pattern.

-	It is used to avoid coupling the code which sends the request to code which handles the request.

-	It allows more than one object chance to handle the request.

-	Objects are chained together with one object holding the reference to another object inside the chain.

-	The client request the first object in the chain to handle the request.

-	When an object can handle the request it does process it otherwise it passes the request down the chain.

Write a note on implementing chain of responsibility design pattern?

-	Define the abstract class or interface handler (LeaveApprover).

-	Define a methods to accept the incoming request and also access the successor object inside the chain.

-	Implement the concrete handler classes.

-	Create chain of objects.

									<<interface>>        	  <<concrete class>>
		  Client					LeaveApprover	 	 	  LeaveApplication								
		  ---------------			---------------		 	  -------------            					
		  | 		    |---------->|		      |     ------| 		  |            
		  ---------------			---------------		|  	  -------------
										  ^				|			     
										 ---			|		   			
										  .				|	           
										  .				|	           
									-------------		|	   
	Employee						|			|<*>-----
	<<concrete class>>				-------------	  		  
									 ^	  ^	   ^
									---  ---  ---
									 .	  .	   .
									 .    .    .
							------------- .	-------------
					Lead	|			| . |			| 	Manager 
		<<concrete class>>	------------- . ------------- <<concrete class>>
										  .
									-------------
									|			|
									-------------
									Director 
									<<concrete class>>
Example:

public class LeaveApplication {

	private int numOfDays;

	private String approvedBy;

	public LeaveApplication(int numOfDays) {
		this.numOfDays = numOfDays;
	}

	public int getNumOfDays() {
		return numOfDays;
	}

	public void setApprovedBy(String approvedBy) {
		this.approvedBy = approvedBy;
	}

	public String getApprovedBy() {
		return approvedBy;
	}
}

public interface LeaveApprover {

	void processLeaveApplication(int numOfDays);

	String getApproverRole();
}

public abstract class Employee implements LeaveApprover {

	private String role;

	private LeaveApprover successor;

	public Employee(String role, LeaveApprover successor) {
		this.role = role;
		this.successor = successor;
	}

	@Override
	public void processLeaveApplication(LeaveApplication application) {

		if (processRequest(application)) {
			application.setApprovedBy(getApproverRole());
			return;
		}
		successor.processLeaveApplication(application);
	}

	@Override
	public String getApproverRole() {
		return role;
	}

	public abstract boolean processRequest(LeaveApplication application);
}

public class Lead extends Employee {

	public Lead(LeaveApprover successor) {
		super("Lead", successor);
	}

	@Override
	public boolean processRequest(LeaveApplication application) {
		if (application.getNumOfDays() <= 2) {
			return true;
		}
		return false;
	}
}

public class Manager extends Employee {

	public Manager(LeaveApprover successor) {
		super("Manager", successor);
	}

	@Override
	public boolean processRequest(LeaveApplication application) {
		if (application.getNumOfDays() <= 5) {
			return true;
		}
		return false;
	}
}

public class Director extends Employee {

	public Director(LeaveApprover successor) {
		super("Director", successor);
	}

	@Override
	public boolean processRequest(LeaveApplication application) {
		return true;
	}
}

public class Client {

	public static void main(String[] args) {
		Director director = new Director(null);
		Manager manager = new Manager(director);
		Lead lead = new Lead(manager);

		LeaveApplication application = new LeaveApplication(4);
		lead.processLeaveApplication(application);
		System.out.println(application.ge);
	}
}

Write a note on design consideration for chain of responsibility design pattern?

-	It is better to define handler as a interface to avoid worrying about single inheritance rule in java.

-	It is possible that a handler will process the request and still forward it to the successor for further processing.

-	It is better to use XML or JSON based configuration to define chain of responsibilities.

-	An existing composite design pattern can be used as a part of chain.

Write a note on pitfalls of chain of responsibility design pattern?

-	There is no guarantee whether the request will be handled or not.

-	It is easy to misconfigure the chain when connecting the successors.

Explain the command design pattern?

-	The command design pattern is a behavioral design pattern.

-	It is used to represent a request or method call as an object.

-	Information about the method parameters and actual operation is encapsulated inside the object called command.

-	The command object can be queued for later execution or send to other part of the code.

Write a note on implementing command design pattern?

-	Define the command interface with no arguement execute method.

-	Implement the command interface for each operation type. We may also implement undo operation if required.

-	Inside concrete implementation define the object on which operation is to be executed (receiver) and parameters.

-	The client code must create command object, receiver object and invoker object.

-	The invoker class may execute in different thread, it uses the command object and executes the operation.

							|---------------------------
							|						   |	
							|		<<interface>>      |  	  <<concrete class>>
		  Client			|		Command	 	 	   |		  MailTaskRunner								
		  ---------------	|		---------------	   |	  -------------            					
		  | 		    |---------->|		      |    ------>| 		  |            
		  ---------------			---------------		  	  -------------
									 ^	  	     ^
									---         ---
									 .	  	     .
									 .           .
							------------- 	   -------------
	    AddMemberCommand	|	   		|	   |		   | 	RemoveMemberCommand 
	    <<concrete class>>	-------------      ------------- 	<<concrete class>>
							  <*>					   <*>
							   |						|
							   |	  EWSService		|
							   |	  <<concrete class>>|
							   |	  -------------		|
							   |------|			  |------
									  -------------
Example:

public interface Command {

	void execute();
}

public class AddMemberCommand implements Command {

	private String email;

	private String group;

	private EWSService receiver;

	public AddMemberCommand(String email, String group, EWSService receiver) {
		this.email = email;
		this.group = group;
		this.receiver = receiver;
	}

	@Override
	public void execute() {
		receiver.addMember(email, group);
	}
}

public class RemoveMemberCommand implements Command {

	private String email;

	private String group;

	private EWSService receiver;

	public RemoveMemberCommand(String email, String group, EWSService receiver) {
		this.email = email;
		this.group = group;
		this.receiver = receiver;
	}

	@Override
	public void execute() {
		receiver.removeMember(email, group);
	}
}

public class MailTaskRunner implements Runnable {

	private Queue<Command> queue = new LinkedList<>();

	public void addCommand(Command command) {
		queue.offer(command);
	}

	@Override
	public void run() {
		while (true) {
			while (!queue.isEmpty()) {
				Command command = queue.poll();
				command.execute();
			}
		}
	}
}

public class Client {

	public static void main(String[] args) {

		EWSService receiver = new EWSService();
		Command addMemberCommand = new AddMemberCommand("durga@gmail.com", "durgasoftware", receiver);

		MailTaskRunner invoker = new MailTaskRunner();
		invoker.addCommand(addMemberCommand);

		new Thread(invoker).start();
	}
}

Write a note on design consideration for command design pattern?

-	We may implement the undo or redo in the command implement.

-	A stateless command object can be reused.

-	We must consider the memory occupied by the state of the command object which is queued.

-	A child command class may be inherited from parent command class.

-	One command object may be composed of multiple other command objects on which execute method must be called in a sequence.

-	For undo operation to save state of command object we may use memento design pattern.

Write a note on pitfalls of command design pattern?

-	Complex to implement exception handling and return a value from the execute method.

Explain the interpreter design pattern?

-	The interpreter design pattern is a behavioral design pattern.

-	It is used to process a simple language with rules or grammar.

-	It allows us to represent rules of language or grammar in a data structure and then interpret sentences in that language.

-	Each class in this pattern represent a rule in the language. 

-	Classes provide method to interpret an expression.

Write a note on implementing interpreter design pattern?

-	Begin with studying the rules of the language.

-	Define an abstract class or interface to represent an expression and define a method inside it to interpret the expression.

-	The expression which do not need other expression to interpret becomes terminal expression (Permission).

-	The expression which need other expression to interpret becomes nonterminal expression (AndExpression OrExpression).

-	Each token of the rule is represented as expression.

-	Building the syntax tree can be done by client or inside another separate class (PermissionExpressionBuilder).

-	A context (User) is passed to the interpreter. It will save the sentence to be interpreted and optionally intermediate computation result.

							|---------------------------------------------------------------------------
							|		<<interface>>         	  <<concrete class>> |	<<concrete class>> | <<concrete class>>
		  Client			|		PermissionExpression	  ExpressionBuilder	 |	User			   |  Report					
		  ---------------	|		---------------	    	  -------------      |  -------------	   |  -------------
		  | 		    |---------->|		      |<*>------->| 		  |      |->|			|	   |->|			  |   
		  ---------------			---------------		  	  -------------			-------------		  -------------
									 ^	   ^     ^
									---   ---   ---
									 .	   .	 .
									 .     .     .
							-------------  .   -------------
			AndExpression	|	   		|  .   |		   | 	OrExpression 
		<<concrete class>>	-------------  .   ------------- 	<<concrete class>>
										   .
									  -------------		
									  |			  |	Permission
									  -------------	<<concrete class>>

Example:

public class Report {

	private String rule;

	public Report(String rule) {
		this.rule = rule;
	}

	public String getRule() {
		return rule;
	}
}

public class User {

	private List<String> roles;

	public User(List<String> roles) {
		this.roles = roles;
	}

	public List<String> getRoles() {
		return roles;
	}
}

public interface PermissionExpression {

	boolean interpret(User user);
}

public class Permission implements PermissionExpression {

	private String role;

	public Permission(String role) {
		this.role = role;
	}

	@Override
	public boolean interpret(User user) {
		return user.getRoles().contains(role);
	}
}

public class AndExpression implements PermissionExpression {

	private PermissionExpression expression1;

	private PermissionExpression expression2;

	public AndExpression(PermissionExpression expression1, PermissionExpression expression2) {
		this.expression1 = expression1;
		this.expression2 = expression2;
	}

	@Override
	public boolean interpret(User user) {
		return expression1.interpret(user) && expression2.interpret(user);
	}
}

public class OrExpression implements PermissionExpression {

	private PermissionExpression expression1;

	private PermissionExpression expression2;

	public OrExpression(PermissionExpression expression1, PermissionExpression expression2) {
		this.expression1 = expression1;
		this.expression2 = expression2;
	}

	@Override
	public boolean interpret(User user) {
		return expression1.interpret(user) || expression2.interpret(user);
	}

}

public class PermissionExpressionBuilder {

	public PermissionExpression build(Report report) {

		String[] tokens = report.getRule().split(" ");

		if (tokens.length == 1) {
			return new Permission(tokens[0]);
		}

		if ("and".equals(tokens[1])) {
			return new AndExpression(new Permission(tokens[0]), new Permission(tokens[2]));
		} else if ("or".equals(tokens[1])) {
			return new OrExpression(new Permission(tokens[0]), new Permission(tokens[2]));
		}

		throw new IllegalArgumentException();
	}
}

public class Client {

	public static void main(String[] args) {

		Report report = new Report("admin or durga");
		PermissionExpressionBuilder builder = new PermissionExpressionBuilder();
		PermissionExpression expression = builder.build(report);

		User user = new User(Collections.singletonList("durga"));
		System.out.println(expression.interpret(user));
	}
}

Write a note on design consideration for interpreter design pattern?

-	Additional operation such as pretty printing can be included.

-	There is no specific convention for parsing and building syntax tree.

-	Context object can save and access the state of expression.

-	We may use visitor design pattern instead of using interpret method inside expression class.

-	We can use flyweight design pattern for terminal operation.

-	The terminal operation can be reused.

Write a note on pitfalls of interpreter design pattern?

-	Class per rule will result into large number of classes.

-	Interpreter design pattern is not suitable for language with complex grammar rule.

-	It is used to address a particular problem like interpreting language only.

Explain the mediator design pattern?

-	The mediator design pattern is a behavioral design pattern.

-	It encapsulates how set of objects interact with each other.

-	The interaction is encapsulated inside the mediator object and interacting objects only know about it.

-	There is a loose coupling between interacting objects.

-	Interaction can now change without changing the participant objects.

-	Changing the mediator allows to add or remove participants in an interaction. 

Write a note on implementing mediator design pattern?

-	Define mediator class.

-	Define method which will be called by participant object to inform its state change.

-	The method must know which data member or participant object is changed.

-	Implement method to interactwith participant objects and inform them about the state changed.

-	Mediator needs to know the participant objects, it can create them or they can register with it.

-	Handle infinite loop resulting from change notify change.

Write a note on design consideration for mediator design pattern?

-	Mediator must identify which participant object's state is changed and must not inform it about the same.

-	If a participant object requires too long to process the state change of another participant object then it may impact the overall performance of mediator.

-	We can extend the mediator and create different possibilities of interactions under different situations.

-	Having abstract mediator instead of concrete is not always required.

-	We can use observer design pattern through which participant objects will inform the mediator about their state change.

							|---------------------------
							|						   |	
							|		<<interface>>      |  	  <<concrete class>>
		  Client			|		UIControl	 	   |	  UIMediator								
		  ---------------	|		---------------	   |	  -------------            					
		  | 		    |---------->|		      |--  ------>| 		  |            
		  ---------------			---------------	|	  	  -------------
									 ^	  	     ^	|				<>
									---         --- |----------------|				 
									 .	  	     .
									 .           .
							------------- 	   -------------
	    Label				|	   		|	   |		   | 	Slider 
	    <<concrete class>>	-------------      ------------- 	<<concrete class>>


Example:

public interface UIControl {

	void controlChanged(UIControl control);

	String getValue();
}

public class Label implements UIControl {

	private UIMediator mediator;

	private String value;

	public Label(UIMediator mediator) {
		this.mediator = mediator;
		mediator.register(this);
	}

	@Override
	public void controlChanged(UIControl control) {
		this.value = control.getValue();
	}

	@Override
	public String getValue() {
		return value;
	}
}

public class Slider implements UIControl {

	private UIMediator mediator;

	private String value;

	public Slider(UIMediator mediator) {
		this.mediator = mediator;
		mediator.register(this);
	}

	@Override
	public void controlChanged(UIControl control) {
		this.value = control.getValue();
	}

	@Override
	public String getValue() {
		return value;
	}
}

public class UIMediator {

	private List<UIControl> participants;

	public UIMediator() {
		participants = new ArrayList<>();
	}

	public void register(UIControl control) {
		participants.add(control);
	}

	public void valueChanged(UIControl control) {
		participants.stream().filter(participant -> participant != control)
				.forEach(participant -> participant.controlChanged(control));
	}
}

Write a note on pitfalls of mediator design pattern?

-	Difficult to maintainas mediator complexity grows.

-	Difficult to implement as reusable mediator.

Explain the iterator design pattern?

-	The iterator design pattern is a behavioral design pattern.

-	It allows to access elements of an aggregate object in sequence while hiding the internal data structure.

-	Iterator is stateful i.e. it remembers its position while iterating.

-	It becomes out of sync if underlying aggregate object is changed.

Write a note on implementing iterator design pattern?

-	Declare iterator interface.

-	Implement the iterator as inner class inorder to access tthe elements of aggregate object.

-	Maintain the state to know the position inside the elements aggregate object.

-	Throw exception if aggregate object is changed while iterating.

									   
		  Client					Iterator <<interface>>	 	 						
		  ---------------			---------------				
		  | 		    |---------->|		      |  
		  ---------------			---------------	
									 ^	  
									---   
									 .	  
									 .    
							-------------			------------- 
	    ThemeColorIterator	|	   		|--------(+)|	   		|	ThemeColor
	    <<concrete class>>	-------------		    -------------	<<concrete class>>

Example:

public interface Iterator {

	boolean hasNext();

	String next();
}

public class ThemeColor {

	private String[] colors;

	public ThemeColor() {
		colors = new String[] { "Red", "Green", "Blue", "Pink" };
	}

	public Iterator getIterator() {
		return new ThemeColorIterator();
	}

	private class ThemeColorIterator implements Iterator {

		private int position;

		@Override
		public boolean hasNext() {
			return position < colors.length;
		}

		@Override
		public String next() {
			return colors[position++];
		}

	}
}

public class Client {

	public static void main(String[] args) {

		ThemeColor themeColor = new ThemeColor();
		Iterator iterator = themeColor.getIterator();

		while (iterator.hasNext()) {
			System.out.println(iterator.next());
		}
	}
}

Write a note on design consideration for iterator design pattern?

-	Identifying changes to underlying aggregate object while client is using iterator is important.

-	Iterator implementation as inner class is recommended as it makes it easy to access elements of aggregate object.

-	Use iterator interface and hide the implementation from the client.

-	Iterator can be used in use cases without collection as well.

Write a note on pitfalls of iterator design pattern?

-	Access to index isn't available to client while iterating.

-	Changes to the aggregate object makes iterator invalid.

Explain the memento design pattern?

-	The memento design pattern is a behavioral design pattern.

-	It allows to save the object's state (originator) without exposing exposing the internal details.

-	We can restore the object's state to previously saved state.

-	The object can return its state as a sealed object which doesn't allow state modification.

-	It is used along with command design pattern to provide the undo functionality.

Write a note on implementing memento design pattern?

-	Find the originator state which needs to be saved.

-	Memento must not be allowed to be changed and read outside originator.

-	The originator class must provide method which records snapshot and provides object of memento.

-	Also another method to restore the originator state to memento state.

																														<<interface>>
		  Client																										Command	    						
		  ---------------																								---------------				
		  | 		    |---------------------------------------------------------------------------------------------->|		      |  
		  ---------------								|																---------------	
														|																	   ^	  
														|																	  ---
														|																	   .				   
														|																	   .	  
														V																	   .    
							-------------			------------- 						-------------					---------------   
	    Memento				|	   		|--------(+)|	   		|<*>--------------------|		    |				    |		      |		AddWorkflowCommand	
	    <<concrete class>>	-------------		    -------------	  					-------------   	        	---------------		<<concrete class>>
                                  |                       | 	WorkflowDesigner        Workflow    						  <*>	 
                                  |                       |     <<concrete class>>      <<concrete class>>        			   |
							      |						  |																	   |
								  ----------------------------------------------------------------------------------------------

Example:

public class Workflow {

	private String name;

	private LinkedList<String> steps;

	public Workflow(String name, LinkedList<String> steps) {
		this.name = name;
		this.steps = new LinkedList<>(steps);
	}

	public String getName() {
		return name;
	}

	public LinkedList<String> getSteps() {
		return steps;
	}
}

public class WorkflowDesigner {

	private Workflow workflow;

	public WorkflowDesigner(String name) {
		this.workflow = new Workflow(name, new LinkedList<String>());
	}

	public Memento geMemento() {
		return new Memento(workflow.getName(), workflow.getSteps());
	}

	public void setMemento(Memento memento) {
		this.workflow = new Workflow(memento.getName(), new LinkedList<String>(memento.getSteps()));
	}

	public void addStep(String step) {
		workflow.getSteps().add(step);
	}

	public void show() {
		System.out.println(workflow.getSteps());
	}

	public class Memento {

		private String name;

		private LinkedList<String> steps;

		private Memento(String name, LinkedList<String> steps) {
			this.name = name;
			this.steps = new LinkedList<>(steps);
		}

		private String getName() {
			return name;
		}

		private LinkedList<String> getSteps() {
			return steps;
		}
	}
}

public interface WorkflowCommand {

	public void execute();

	public void undo();
}

public class AddWorkflowCommand implements WorkflowCommand {

	private WorkflowDesigner orignator;

	private WorkflowDesigner.Memento memento;

	private String step;

	public AddWorkflowCommand(WorkflowDesigner orignator, String step) {
		this.orignator = orignator;
		this.step = step;
	}

	@Override
	public void execute() {
		this.memento = orignator.geMemento();
		orignator.addStep(step);
	}

	@Override
	public void undo() {
		orignator.setMemento(memento);
	}
}

public class Client {

	public static void main(String[] args) {

		WorkflowDesigner orignator = new WorkflowDesigner("Leave workflow");

		WorkflowCommand command1 = new AddWorkflowCommand(orignator, "Create Leave Application");
		WorkflowCommand command2 = new AddWorkflowCommand(orignator, "Submit Leave Application");
		WorkflowCommand command3 = new AddWorkflowCommand(orignator, "Leave Application Approved");

		command1.execute();
		command2.execute();
		command3.execute();

		orignator.show();
		command3.undo();
		orignator.show();
	}
}

Write a note on design consideration for memento design pattern?

-	Be careful about the size of memento state. One solution is to discard older saved states.

-	The memento class must be inner class to originator class to ensure it is read only by originator.

-	Restoring to a previous state must consider the effect on the state of another objects.

-	If there is a definite fixed way in which mementos are created (using command design pattern) then only delta states can be saved. 

-	Memento encapsulated inside originator might increase the implementation complexity.

Write a note on pitfalls of memento design pattern?

-	Creating a snapshot is not easy if the orignator object encapsulates another objects.

-	Resetting the state of an orignator object might cause other related object's state to become out of sync.

Explain the observer design pattern?

-	The observer design pattern is a behavioral design pattern.

-	It is also called as publisher subscriber or pub sub design pattern.

-	It is used to notify multiple objects (observers) about a state change in an object(observable).

-	There is no tight coupling between the observers and observable.

-	The observer must query to identify the state change inside the observable.

Write a note on implementing observer design pattern?

-	Declare the observer interface.

-	Declare a method to notify observers about state change in observable.

-	A subject can be interface if observers are observing multiple observables otherwise it can be a concrete class.

-	Implement subject to provide functionality to attach and detach from observable, notify registered observers and provide state information to the observers. 

						---------------------------------------------------------------------|
						|																	 |
						|				OrderObservable				Order					 |
			  Client	|				<<interface>>				<<concrete class>>		 |	
			  ---------------		    -------------				-------------        	 |
	          | 		    |---------->|			|------------<*>|			|<-----------|
	          ---------------		    -------------				-------------		
                                 		  ^       ^   		
                                		 ---	 ---		
                                 		  .       .			
                                  		  .       .			
                                 -------------	-------------
            PriceObservable      |  		 |  |			| 	QuantityObservable
            <<concrete class>>   -------------  -------------	<<concrete class>>
                                  

Example:

public class Order {

	private int count;

	private double itemCost;

	private List<OrderObserver> observerList;

	public Order() {
		observerList = new ArrayList<>();
	}

	public void addItem(int cost) {
		itemCost = itemCost + cost;
		count++;
		observerList.forEach(observer -> observer.updated(this));
	}

	public double getItemCost() {
		return itemCost;
	}

	public int getCount() {
		return count;
	}

	public void attach(OrderObserver observer) {
		observerList.add(observer);
	}

	public void detach(OrderObserver observer) {
		observerList.remove(observer);
	}
}

public interface OrderObserver {

	void updated(Order order);
}

public class PriceObserver implements OrderObserver {

	@Override
	public void updated(Order order) {

		if (order.getItemCost() >= 1000) {
			System.out.println("Order is eligible for discount");
		}
	}
}

public class QuantityObserver implements OrderObserver {

	@Override
	public void updated(Order order) {

		if (order.getCount() >= 3) {
			System.out.println("Order is eligible for free shipping");
		}
	}
}

public class Client {

	public static void main(String[] args) {

		Order order = new Order();
		PriceObserver priceObserver = new PriceObserver();
		QuantityObserver quantityObserver = new QuantityObserver();

		order.attach(priceObserver);
		order.attach(quantityObserver);

		order.addItem(100);
		order.addItem(200);
		order.addItem(300);
		order.addItem(400);
		order.addItem(500);
	}
}

Write a note on design consideration for observer design pattern?

-	In some cases it may encounter circular update loop.

-	An observer can listen for change into multiple observables, hence the observable must pass its reference when notifying.

-	Too many observers and slow observers can make it costly.

-	We can have observer register to observable for specific state change.

-	Instead of observable we can implement client code to send notification.

Write a note on pitfalls of observer design pattern?

-	Every setter method triggering notification may be too much if we have a client setting properties on after another on the observable.

-	Each update become costly if we have too many observers and one or more observer is slow.

-	Complexity increases if the observers query to find exact state change in observable.

Explain the state design pattern?

-	The state design pattern is a behavioral design pattern.

-	It allows the object (context) to behave differently based on its current internal state.

-	It allows to define state specific behavior inside different classes.

-	 Any operation on the context will delegate it to the state specific implementation.

-	New state and behavior can be added without changing the context class.

Write a note on implementing state design pattern?

-	Identify distinct states of the object.

-	Implement each state as a separate class which provide behavior specific to that state.

-	Implement method inside context class to delegate operation to state class.

-	Identify state transition.

-	The state transition can be done by state implementation or client code.

-	If state  transition is done by state implementation then the client code is unaware of the state classes.

						---------------------------------------------------------------------|
						|																	 |
						|				OrderState					Order					 |
			  Client	|				<<interface>>				<<concrete class>>		 |	
			  ---------------		    -------------				-------------        	 |
	          | 		    |			|			|------------<*>|			|<-----------|
	          ---------------		    -------------				-------------		
											  ^  	   		
											 --- 	 		
                                 		   	  |			
                -------------------------------------------------------------
				|			   |			  |				  |				|
        -------------	-------------	-------------	-------------	-------------
        |		    |	|		    |	|		    |	|		    |	|		    | 
        -------------	-------------	-------------	-------------	-------------
		NewState		PaidState		InTransitState	DeliveredState	CancelledState
									 <<concrete classes>>	
Example:

public class Order {

	private OrderState state;

	public Order() {
		this.state = new NewState();
	}

	public double cancel() {
		double charges = state.handleCancellation();
		this.state = new CancelledState();
		return charges;
	}

	public void paymentSuccessful() {
		this.state = new PaidState();
	}

	public void dispatched() {
		this.state = new InTransitState();
	}

	public void delivered() {
		this.state = new DeliveredState();
	}
}

public interface OrderState {

	double handleCancellation();
}

public class NewState implements OrderState {

	@Override
	public double handleCancellation() {
		return 0;
	}

}

public class PaidState implements OrderState {

	@Override
	public double handleCancellation() {
		return 50;
	}
}

public class InTransitState implements OrderState {

	@Override
	public double handleCancellation() {
		return 100;
	}
}

public class DeliveredState implements OrderState {

	@Override
	public double handleCancellation() {
		return 150;
	}
}

public class CancelledState implements OrderState {

	@Override
	public double handleCancellation() {
		throw new IllegalStateException();
	}

}

public class Client {

	public static void main(String[] args) {

		Order order = new Order();
		order.paymentSuccessful();
		order.dispatched();
		double charges = order.cancel();
		System.out.println("Cancellation charges " + charges);
	}
}

Write a note on design consideration for state design pattern?

-	We may ask the client code to initialise the context with specific initial state.

-	If state transition is done by state class then it needs to know atleast one state, this requires code change for adding new state.

-	Using flyweight design pattern we can share state objects without data members but only member methods.

-	It is not same as state machine (only transition no behavior).

Write a note on pitfalls of state design pattern?

-	Too many states will result into too many classes which will require unit testing.

-	The state transition may become complex if there are multiple possible states to which a context can be transitined from current state.

-	This may create coupling between the states.

-	We may not identify all possible states at beginning hence we will have to add more states to handle behavior as design evolves.

Explain the strategy design pattern?

-	The strategy design pattern is a behavioral design pattern.

-	It allows to encapsulate an algorithm inside the class.

-	It is useful hen there are multiple algorithms available.

-	It uses inheritance hierarchy to provide implementation for different algorithm.

Write a note on implementing strategy design pattern?

-	Define the strategy interface.

-	The context class supplies necessary parameters to the strategy object.

-	Implement strategy interface using one class per algorithm.

-	The client code will create context object and configure it with one of the strategy implementation object.

						---------------------------------------------------------------------|
						|																	 |
						|				OrderPrinter				PrintToFileService		 |
			  Client	|				<<interface>>				<<concrete class>>		 |	
			  ---------------		    -------------				-------------        	 |
	    |-----| 		    |---------->|			|------------<*>|			|<-----------|
	    |     ---------------		    -------------				-------------		
        |                            	 ^         ^   				
        |  		 			       		---	      ---				
        |                            	 .         .			    
        |                                .         .			    
		|  -------------	  -------------	      -------------
		-->|		   |	  |  		  |       |		      | 	
		   -------------	  -------------       -------------	
		   Order			  DetailPrinter	      SummaryPrinter
		   <<concrete class>> <<concrete class>> <<concrete class>>
								 
Example:

public class Order {

	private String id;

	private LocalDate date;

	private Map<String, Double> items;

	public Order(String id, LocalDate date) {
		this.id = id;
		this.date = date;
		this.items = new HashMap<>();
	}

	public void addItem(String name, double price) {
		items.put(name, price);
	}

	public String getId() {
		return id;
	}

	public LocalDate getDate() {
		return date;
	}

	public Map<String, Double> getItems() {
		return items;
	}
}

public interface OrderPrinter {

	String print(Order order);
}

public class SummaryPrinter implements OrderPrinter {

	@Override
	public String print(Order order) {
		StringBuilder builder = new StringBuilder();
		return builder.append("Id = ").append(order.getId())
				.append(" Date = " + order.getDate() + " Items = " + order.getItems().size()).toString();
	}
}

public class DetailPrinter implements OrderPrinter {

	@Override
	public String print(Order order) {

		StringBuilder builder = new StringBuilder();
		builder.append("Id = ").append(order.getId())
				.append(" Date = " + order.getDate() + " Items = " + order.getItems().size());
		builder.append("\n");

		double total = 0;
		for (Map.Entry<String, Double> item : order.getItems().entrySet()) {
			builder.append("Name = " + item.getKey() + " Price = " + item.getValue());
			builder.append("\n");
			total = total + item.getValue();
		}

		builder.append("Total = " + total);

		return builder.toString();
	}
}

public class PrintToFileService {

	private OrderPrinter orderPrinter;

	public PrintToFileService(OrderPrinter orderPrinter) {
		this.orderPrinter = orderPrinter;
	}

	public void printOrder(Order order) {
		System.out.println(orderPrinter.print(order));
	}
}

public class Client {

	public static void main(String[] args) {

		Order order = new Order("O001", LocalDate.now());
		order.addItem("chips", 120);
		order.addItem("cookies", 746);
		order.addItem("soda", 180);
		order.addItem("fries", 780);

		OrderPrinter orderPrinter = new DetailPrinter();
		PrintToFileService service = new PrintToFileService(orderPrinter);
		service.printOrder(order);
	}
}

Write a note on design consideration for strategy design pattern?

-	We can implement context object with optional strategy object, this allows reusing context object.

-	If number of parameters supplied by the context object to strategy object are more we can pass strategy object an interface which it can query to get the parameters.

-	A strategy object is stateless and can be shared between context objects using flyweight design pattern.

-	Use inheritance to implement common part of the algorithm into base class and making child class implementation simpler.

Write a note on pitfalls of strategy design pattern?

-	Client code must know all implementations of strategy.

-	Client code needs change when new implementation of strategy is available.

Explain the template method design pattern?

-	The template method design pattern is a behavioral design pattern.

-	It defines an algorithm inside a method (template) as sequence of steps or method calls.

-	It allows child classes to override and provide implementation for these steps.

-	It allow to defer implementation of parts of an algorithm which can change.

-	It is an example of inversion of control principle.

Write a note on implementing template method design pattern?

-	Define the template method with an algorithm.

-	Break the algorithm into multiple steps.

-	Make sure not too many steps or methods to implement inside child classes.

-	Implement the abstract methods inside child classes.

										OrderPrinter
			  Client					<<interface>>
			  ---------------		    -------------
	    |-----| 		    |---------->|			|
	    |     ---------------		    -------------
        |                            	 ^         ^ 
        |  		 			       		---	      ---				
        |                            	 .         .			    
        |                                .         .			    
		|  -------------	  -------------	      -------------
		-->|		   |	  |  		  |       |		      | 	
		   -------------	  -------------       -------------	
		   Order			  HtmlPrinter	      TextPrinter
		   <<concrete class>> <<concrete class>> <<concrete class>>


Example:

public class Order {

	private String id;

	private LocalDate date;

	private Map<String, Double> items;

	public Order(String id, LocalDate date) {
		this.id = id;
		this.date = date;
		this.items = new HashMap<>();
	}

	public void addItem(String name, double price) {
		items.put(name, price);
	}

	public String getId() {
		return id;
	}

	public LocalDate getDate() {
		return date;
	}

	public Map<String, Double> getItems() {
		return items;
	}
}

public abstract class OrderPrinter {

	public void printOrder(Order order) {

		StringBuilder builder = new StringBuilder();
		builder.append(start()).append(formatId(order)).append(formatItems(order)).append(formatTotal(order))
				.append(end());

		System.out.println(builder);
	}

	protected abstract String start();

	protected abstract String formatId(Order order);

	protected abstract String formatItems(Order order);

	protected abstract String formatTotal(Order order);

	protected abstract String end();

}

public class HtmlOrderPrinter extends OrderPrinter {

	@Override
	protected String start() {
		return "<html><head><title>Order Details</title></head><body>";
	}

	@Override
	protected String formatId(Order order) {
		return "<b>Id = " + order.getId() + "</b>";
	}

	@Override
	protected String formatItems(Order order) {

		StringBuilder builder = new StringBuilder();
		builder.append("<table><th><td>Name</td><td>Price</td></th>");

		for (Map.Entry<String, Double> item : order.getItems().entrySet()) {
			builder.append("<tr>");
			builder.append("<td>" + item.getKey() + "</td><td>" + item.getValue() + "<td>");
			builder.append("</tr>");
		}
		builder.append("</table>");
		return builder.toString();
	}

	@Override
	protected String formatTotal(Order order) {

		double total = 0;
		for (Map.Entry<String, Double> item : order.getItems().entrySet()) {
			total = total + item.getValue();
		}

		return "<b>Total = " + total + "</b>";
	}

	@Override
	protected String end() {
		return "</body></html>";
	}

}

public class TextOrderPrinter extends OrderPrinter {

	@Override
	protected String start() {
		return "[";
	}

	@Override
	protected String formatId(Order order) {
		return "Id = " + order.getId();
	}

	@Override
	protected String formatItems(Order order) {

		StringBuilder builder = new StringBuilder();
		for (Map.Entry<String, Double> item : order.getItems().entrySet()) {
			builder.append("Name = " + item.getKey() + " Price = " + item.getValue());
			builder.append("\n");
		}

		return builder.toString();
	}

	@Override
	protected String formatTotal(Order order) {

		double total = 0;
		for (Map.Entry<String, Double> item : order.getItems().entrySet()) {
			total = total + item.getValue();
		}

		return "Total = " + total;
	}

	@Override
	protected String end() {
		return "]";
	}

}

public class Client {

	public static void main(String[] args) {

		Order order = new Order("O001", LocalDate.now());
		order.addItem("chips", 120);
		order.addItem("cookies", 746);
		order.addItem("soda", 180);
		order.addItem("fries", 780);

		OrderPrinter orderPrinter = new HtmlOrderPrinter();
		orderPrinter.printOrder(order);
	}
}

Write a note on design consideration for template method design pattern?

-	A balance must be kept in how much granular we want to keep the algorithm steps.

-	Too many steps will cause the child classes to implement too many methods.

-	Too few steps will cause the child classes to implement major parts of the algorithm.

-	We can prevent the child classes from overriding the template method by using final keyword.

-	We can use multi level and hierarchical inheritance between child classes inorder to reuse steps.

-	Factory method design pattern uses template method design pattern, actual factory method is often called as part of another template method.

Write a note on pitfalls of template method design pattern?

-	It is difficult to track the complete steps executed as part of algorithm which might be present across multiple child classes (multi level inheritance).

-	Unit testing can be difficult as individual step might require some specific state value to be present.

Explain the visitor design pattern?

-	The visitor design pattern is a behavioral design pattern.

-	It allows to define new operation that can be performed on an object without changing the class definition of the object.

-	An object (visitor) visits all other objects in  object structure. 

-	The object calls a specific method on visitor passing itself as arguement.

-	Each time we need a new operation we create a child class of visitor and implement it and visit the object structure.

-	Objects themselves only implement an accept visit where the visitor is passed as an arguement.

-	Objects know that method inside visitor is created specifically for it and call it inside the accept method.

Write a note on implementing visitor design pattern?

-	Declare visitor interface with multiple visit method specific to each concrete class.

-	Implement the visitor interface and provide specific functionality for interested class.

-	Define concrete classes with accept method to use visitor's functionality.

-	Implement the accept method to call functionality of visitor defined specifically for that class.


					  |----------------------------------------------------------------
					  |																  |	
				--------------			-------------								  |		-------------
		Client	| 		     |--------->| 		    |	Employee					  |---->|			|	Visitor		
				--------------		    -------------	<<interface>>				        -------------	<<interface>>
											  ^													  ^
											 ---			                                	 ---
											  | 			                                	  |	
										-------------                                       	  |  	  
										|			|	AbstractEmployee                    	  |	 
										-------------	<<abstract class>>                     	  |			
											  ^  	   		                                	  |
											 --- 	 		                                	  |			
                                 		   	  |			                                    	  |
                -------------------------------------------------------------               	  |
				|			   |			  				  |				|               	  |
        -------------	-------------					-------------	-------------       -------------
        |		    |	|		    |			    	|		    |	|		    |       |		    |
        -------------	-------------					-------------	-------------       -------------
		Programmer		ProjectLead						Manager			VicePresident       PrintVisitor
									 <<concrete classes>>                                   <<concrete class>>

Example:

public interface Employee {

	String getEmployeeId();

	int getPerformanceRating();

	void setPerformanceRating(int performanceRating);

	Collection<Employee> getDirectReports();

	void accept(Visitor visitor);
}

public abstract class AbstractEmployee implements Employee {

	private String employeeId;

	private int performanceRating;

	public AbstractEmployee(String employeeId) {
		this.employeeId = employeeId;
	}

	@Override
	public int getPerformanceRating() {
		return performanceRating;
	}

	@Override
	public void setPerformanceRating(int performanceRating) {
		this.performanceRating = performanceRating;

	}

	@Override
	public Collection<Employee> getDirectReports() {
		return Collections.emptyList();
	}

	@Override
	public String getEmployeeId() {
		return employeeId;
	}
}

public class Programmer extends AbstractEmployee {

	private String skill;

	public Programmer(String employeeId, String skill) {
		super(employeeId);
		this.skill = skill;
	}

	public String getSkill() {
		return skill;
	}

	@Override
	public void accept(Visitor visitor) {
		visitor.visit(this);
	}
}

public class ProjectLead extends AbstractEmployee {

	private List<Employee> directReportees;

	public ProjectLead(String employeeId, List<Employee> directReportees) {
		super(employeeId);
		this.directReportees = new ArrayList<>(directReportees);
	}

	@Override
	public Collection<Employee> getDirectReports() {
		return directReportees;
	}

	@Override
	public void accept(Visitor visitor) {
		visitor.visit(this);
	}
}

public class Manager extends AbstractEmployee {

	private List<Employee> directReportees;

	public Manager(String employeeId, List<Employee> directReportees) {
		super(employeeId);
		this.directReportees = new ArrayList<>(directReportees);
	}

	@Override
	public Collection<Employee> getDirectReports() {
		return directReportees;
	}

	@Override
	public void accept(Visitor visitor) {
		visitor.visit(this);
	}
}

public class VicePresident extends AbstractEmployee {

	private List<Employee> directReportees;

	public VicePresident(String employeeId, List<Employee> directReportees) {
		super(employeeId);
		this.directReportees = new ArrayList<>(directReportees);
	}

	@Override
	public Collection<Employee> getDirectReports() {
		return directReportees;
	}

	@Override
	public void accept(Visitor visitor) {
		visitor.visit(this);
	}
}

public interface Visitor {

	void visit(Programmer programmer);

	void visit(ProjectLead projectLead);

	void visit(Manager manager);

	void visit(VicePresident vicePresident);
}

public class PrintVisitor implements Visitor {

	@Override
	public void visit(Programmer programmer) {
		System.out.println("Employee " + programmer.getEmployeeId() + " is a " + programmer.getSkill() + " programmer");
	}

	@Override
	public void visit(ProjectLead projectLead) {
		System.out.println("Employee " + projectLead.getEmployeeId() + " is a project lead with "
				+ projectLead.getDirectReports().size() + " direct reportees");
	}

	@Override
	public void visit(Manager manager) {
		System.out.println("Employee " + manager.getEmployeeId() + " is a manager with "
				+ manager.getDirectReports().size() + " direct reportees");
	}

	@Override
	public void visit(VicePresident vicePresident) {
		System.out.println("Employee " + vicePresident.getEmployeeId() + " is a vice president with "
				+ vicePresident.getDirectReports().size() + " direct reportees");
	}
}

public class Client {

	public static void main(String[] args) {

		Employee emp = buildOrganisation();
		Visitor visitor = new PrintVisitor();

		visitOrganisation(emp, visitor);
	}

	public static Employee buildOrganisation() {

		Programmer programmer1 = new Programmer("PG001", "c");
		Programmer programmer2 = new Programmer("PG002", "c++");
		Programmer programmer3 = new Programmer("PG003", "java");
		Programmer programmer4 = new Programmer("PG004", "python");

		ProjectLead projectLead1 = new ProjectLead("PL001", List.of(programmer1, programmer2));
		ProjectLead projectLead2 = new ProjectLead("PL002", List.of(programmer3, programmer4));

		Manager manager1 = new Manager("MG001", List.of(projectLead1, projectLead2));

		VicePresident vicePresident = new VicePresident("VP001", List.of(manager1));

		return vicePresident;
	}

	public static void visitOrganisation(Employee emp, Visitor visitor) {
		emp.accept(visitor);
		emp.getDirectReports().forEach(reportee -> visitOrganisation(reportee, visitor));
	}
}

Write a note on design consideration for visitor design pattern?

-	Visitor can work with objects of classes which do not have a common parent.

-	But the code which passes our visitor to these object must be aware of these individual classes.

-	Visitor need access to internal state of object therefore we need to expose getter methods.

-	The related functionality is grouped inside single visitor class, so to add a new functionality we need a new visitor implementation.

-	Visitor can accumulate state of different objects inside object structure.

-	Visitor can add new functionality to object structure implemented using composite design pattern or can be used for doing interpretation in interpreter design pattern.

Write a note on pitfalls of visitor design pattern?

-	Visitor needs access to object state, therefore too many getter method are required inside object class which weakens encapsulation.

-	To add new object class we need to change the visitor implementation.

-	Any change in object class will require change in visitor implementation.

-	Complex to understand and implement.

Explain the null object design pattern?

-	The null object design pattern is a behavioral design pattern.

-	It is used to provide an alternate representation to indicate absence of object.

-	It is used to treat absence of a collaborator transparently without null checks.

-	It will do nothing or save nothing when an operation is called on it.

-	It seems like a proxy to real object but it doesn't transform into real object.

Write a note on implementing null object design pattern?

-	Create null class by inheriting from base class or implementing base interface.

-	Implement do nothing methods.

-	Code which creates object of implementing will create and pass null object under specific situation.


						---------------------------------------------------------------------|
						|																	 |
						|				StorageService				ComplexService 			 |
			  Client	|				<<concrete class>>			<<concrete class>>		 |	
			  ---------------		    -------------				-------------        	 |
	      ----| 		    |---------->|			|<*>------------|			|<-----------|
	      |   ---------------		    -------------				-------------		
          |                     		      ^      
		  |		 						 	 ---	 
          |                     		      .      
          |                     		      .      
	      |  -------------				-------------
		  |->|			 |				|	  		|
			 -------------				-------------
			  Report					NullStorageService
			  <<concrete class>>		<<concrete class>>

Example:

public class Report {

	private String name;

	private String contents;

	public Report(String name, String contents) {
		this.name = name;
		this.contents = contents;
	}

	public String getName() {
		return name;
	}

	public String getContents() {
		return contents;
	}
}

public class StorageService {

	public void save(Report report) {

		try (PrintWriter writer = new PrintWriter(report.getName())) {

			writer.println(report.getContents());
		} catch (Exception ex) {
			System.out.println("Failed to write report");
		}
	}
}

public class NullStorageService extends StorageService {

	@Override
	public void save(Report report) {

	}
}

public class ComplexService {

	private StorageService storageService;

	public ComplexService(StorageService storageService) {
		this.storageService = storageService;
	}

	public void saveReport(Report report) {
		storageService.save(report);
	}
}

Write a note on design consideration for null object design pattern?

-	Class using null object should not have to do anything special when working with this object.

-	What do nothing means can be different for different classes, especially when a methods are expected to return a value.

-	Whenever there is a need to transform null object into real object use of state design pattern is recommended instead of null object design pattern.

-	The null object can be implemented as singleton object is possible.

-	They are very useful in other design patterns like state and strategy design patterns.

Write a note on pitfalls of null object design pattern?

-	Creating a null object in not possible for all the classes, implementation classes may be expected to cause a change and absence of the change may cause other functionality to fail.

-	Finding what do nothing means is not easy or always possible.