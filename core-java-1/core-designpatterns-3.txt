core java - design patterns

Explain and enlist behavioral design pattern?

-	The behavioral design pattern deal with how classes and objects interact or communicate with each other.

-	Below are different types of behavioral design patterns,

	-	chain of responsibility
	
	-	command
	
	-	interpreter

Explain the chain of responsibility design pattern?

-	The chain of responsibility design pattern is a behavioral design pattern.

-	It is used to avoid coupling the code which sends the request to code which handles the request.

-	It allows more than one object chance to handle the request.

-	Objects are chained together with one object holding the reference to another object inside the chain.

-	The client request the first object in the chain to handle the request.

-	When an object can handle the request it does process it otherwise it passes the request down the chain.

Write a note on implementing chain of responsibility design pattern?

-	Define the abstract class or interface handler (LeaveApprover).

-	Define a methods to accept the incoming request and also access the successor object inside the chain.

-	Implement the concrete handler classes.

-	Create chain of objects.

									<<interface>>        	  <<concrete class>>
		  Client					LeaveApprover	 	 	  LeaveApplication								
		  ---------------			---------------		 	  -------------            					
		  | 		    |---------->|		      |     ------| 		  |            
		  ---------------			---------------		|  	  -------------
										  ^				|			     
										 ---			|		   			
										  .				|	           
										  .				|	           
									-------------		|	   
	Employee						|			|<*>-----
	<<concrete class>>				-------------	  		  
									 ^	  ^	   ^
									---  ---  ---
									 .	  .	   .
									 .    .    .
							------------- .	-------------
					Lead	|			| . |			| 	Manager 
		<<concrete class>>	------------- . ------------- <<concrete class>>
										  .
									-------------
									|			|
									-------------
									Director 
									<<concrete class>>
Example:

public class LeaveApplication {

	private int numOfDays;

	private String approvedBy;

	public LeaveApplication(int numOfDays) {
		this.numOfDays = numOfDays;
	}

	public int getNumOfDays() {
		return numOfDays;
	}

	public void setApprovedBy(String approvedBy) {
		this.approvedBy = approvedBy;
	}

	public String getApprovedBy() {
		return approvedBy;
	}
}

public interface LeaveApprover {

	void processLeaveApplication(int numOfDays);

	String getApproverRole();
}

public abstract class Employee implements LeaveApprover {

	private String role;

	private LeaveApprover successor;

	public Employee(String role, LeaveApprover successor) {
		this.role = role;
		this.successor = successor;
	}

	@Override
	public void processLeaveApplication(LeaveApplication application) {

		if (processRequest(application)) {
			application.setApprovedBy(getApproverRole());
			return;
		}
		successor.processLeaveApplication(application);
	}

	@Override
	public String getApproverRole() {
		return role;
	}

	public abstract boolean processRequest(LeaveApplication application);
}

public class Lead extends Employee {

	public Lead(LeaveApprover successor) {
		super("Lead", successor);
	}

	@Override
	public boolean processRequest(LeaveApplication application) {
		if (application.getNumOfDays() <= 2) {
			return true;
		}
		return false;
	}
}

public class Manager extends Employee {

	public Manager(LeaveApprover successor) {
		super("Manager", successor);
	}

	@Override
	public boolean processRequest(LeaveApplication application) {
		if (application.getNumOfDays() <= 5) {
			return true;
		}
		return false;
	}
}

public class Director extends Employee {

	public Director(LeaveApprover successor) {
		super("Director", successor);
	}

	@Override
	public boolean processRequest(LeaveApplication application) {
		return true;
	}
}

public class Client {

	public static void main(String[] args) {
		Director director = new Director(null);
		Manager manager = new Manager(director);
		Lead lead = new Lead(manager);

		LeaveApplication application = new LeaveApplication(4);
		lead.processLeaveApplication(application);
		System.out.println(application.ge);
	}
}

Write a note on design consideration for chain of responsibility design pattern?

-	It is better to define handler as a interface to avoid worrying about single inheritance rule in java.

-	It is possible that a handler will process the request and still forward it to the successor for further processing.

-	It is better to use XML or JSON based configuration to define chain of responsibilities.

-	An existing composite design pattern can be used as a part of chain.

Write a note on pitfalls of chain of responsibility design pattern?

-	There is no guarantee whether the request will be handled or not.

-	It is easy to misconfigure the chain when connecting the successors.

Explain the command design pattern?

-	The command design pattern is a behavioral design pattern.

-	It is used to represent a request or method call as an object.

-	Information about the method parameters and actual operation is encapsulated inside the object called command.

-	The command object can be queued for later execution or send to other part of the code.

Write a note on implementing command design pattern?

-	Define the command interface with no arguement execute method.

-	Implement the command interface for each operation type. We may also implement undo operation if required.

-	Inside concrete implementation define the object on which operation is to be executed (receiver) and parameters.

-	The client code must create command object, receiver object and invoker object.

-	The invoker class may execute in different thread, it uses the command object and executes the operation.

							|---------------------------
							|						   |	
							|		<<interface>>      |  	  <<concrete class>>
		  Client			|		Command	 	 	   |		  MailTaskRunner								
		  ---------------	|		---------------	   |	  -------------            					
		  | 		    |---------->|		      |    ------>| 		  |            
		  ---------------			---------------		  	  -------------
									 ^	  	     ^
									---         ---
									 .	  	     .
									 .           .
							------------- 	   -------------
	    AddMemberCommand	|	   		|	   |		   | 	RemoveMemberCommand 
	    <<concrete class>>	-------------      ------------- 	<<concrete class>>
							  <*>					   <*>
							   |						|
							   |	  EWSService		|
							   |	  <<concrete class>>|
							   |	  -------------		|
							   |------|			  |------
									  -------------
Example:

public interface Command {

	void execute();
}

public class AddMemberCommand implements Command {

	private String email;

	private String group;

	private EWSService receiver;

	public AddMemberCommand(String email, String group, EWSService receiver) {
		this.email = email;
		this.group = group;
		this.receiver = receiver;
	}

	@Override
	public void execute() {
		receiver.addMember(email, group);
	}
}

public class RemoveMemberCommand implements Command {

	private String email;

	private String group;

	private EWSService receiver;

	public RemoveMemberCommand(String email, String group, EWSService receiver) {
		this.email = email;
		this.group = group;
		this.receiver = receiver;
	}

	@Override
	public void execute() {
		receiver.removeMember(email, group);
	}
}

public class MailTaskRunner implements Runnable {

	private Queue<Command> queue = new LinkedList<>();

	public void addCommand(Command command) {
		queue.offer(command);
	}

	@Override
	public void run() {
		while (true) {
			while (!queue.isEmpty()) {
				Command command = queue.poll();
				command.execute();
			}
		}
	}
}

public class Client {

	public static void main(String[] args) {

		EWSService receiver = new EWSService();
		Command addMemberCommand = new AddMemberCommand("durga@gmail.com", "durgasoftware", receiver);

		MailTaskRunner invoker = new MailTaskRunner();
		invoker.addCommand(addMemberCommand);

		new Thread(invoker).start();
	}
}

Write a note on design consideration for command design pattern?

-	We may implement the undo or redo in the command implement.

-	A stateless command object can be reused.

-	We must consider the memory occupied by the state of the command object which is queued.

-	A child command class may be inherited from parent command class.

-	One command object may be composed of multiple other command objects on which execute method must be called in a sequence.

-	For undo operation to save state of command object we may use memento design pattern.

Write a note on pitfalls of command design pattern?

-	Complex to implement exception handling and return a value from the execute method.

Explain the interpreter design pattern?

-	The interpreter design pattern is a behavioral design pattern.

-	It is used to process a simple language with rules or grammar.

-	It allows us to represent rules of language or grammar in a data structure and then interpret sentences in that language.

-	Each class in this pattern represent a rule in the language. 

-	Classes provide method to interpret an expression.

Write a note on implementing interpreter design pattern?

-	Begin with studying the rules of the language.

-	Define an abstract class or interface to represent an expression and define a method inside it to interpret the expression.

-	The expression which do not need other expression to interpret becomes terminal expression (Permission).

-	The expression which need other expression to interpret becomes nonterminal expression (AndExpression OrExpression).

-	Each token of the rule is represented as expression.

-	Building the syntax tree can be done by client or inside another separate class (PermissionExpressionBuilder).

-	A context (User) is passed to the interpreter. It will save the sentence to be interpreted and optionally intermediate computation result.

							|---------------------------------------------------------------------------
							|		<<interface>>         	  <<concrete class>> |	<<concrete class>> | <<concrete class>>
		  Client			|		PermissionExpression	  ExpressionBuilder	 |	User			   |  Report					
		  ---------------	|		---------------	    	  -------------      |  -------------	   |  -------------
		  | 		    |---------->|		      |<*>------->| 		  |      |->|			|	   |->|			  |   
		  ---------------			---------------		  	  -------------			-------------		  -------------
									 ^	   ^     ^
									---   ---   ---
									 .	   .	 .
									 .     .     .
							-------------  .   -------------
			AndExpression	|	   		|  .   |		   | 	OrExpression 
		<<concrete class>>	-------------  .   ------------- 	<<concrete class>>
										   .
									  -------------		
									  |			  |	Permission
									  -------------	<<concrete class>>

Example:

public class Report {

	private String rule;

	public Report(String rule) {
		this.rule = rule;
	}

	public String getRule() {
		return rule;
	}
}

public class User {

	private List<String> roles;

	public User(List<String> roles) {
		this.roles = roles;
	}

	public List<String> getRoles() {
		return roles;
	}
}

public interface PermissionExpression {

	boolean interpret(User user);
}

public class Permission implements PermissionExpression {

	private String role;

	public Permission(String role) {
		this.role = role;
	}

	@Override
	public boolean interpret(User user) {
		return user.getRoles().contains(role);
	}
}

public class AndExpression implements PermissionExpression {

	private PermissionExpression expression1;

	private PermissionExpression expression2;

	public AndExpression(PermissionExpression expression1, PermissionExpression expression2) {
		this.expression1 = expression1;
		this.expression2 = expression2;
	}

	@Override
	public boolean interpret(User user) {
		return expression1.interpret(user) && expression2.interpret(user);
	}
}

public class OrExpression implements PermissionExpression {

	private PermissionExpression expression1;

	private PermissionExpression expression2;

	public OrExpression(PermissionExpression expression1, PermissionExpression expression2) {
		this.expression1 = expression1;
		this.expression2 = expression2;
	}

	@Override
	public boolean interpret(User user) {
		return expression1.interpret(user) || expression2.interpret(user);
	}

}

public class PermissionExpressionBuilder {

	public PermissionExpression build(Report report) {

		String[] tokens = report.getRule().split(" ");

		if (tokens.length == 1) {
			return new Permission(tokens[0]);
		}

		if ("and".equals(tokens[1])) {
			return new AndExpression(new Permission(tokens[0]), new Permission(tokens[2]));
		} else if ("or".equals(tokens[1])) {
			return new OrExpression(new Permission(tokens[0]), new Permission(tokens[2]));
		}

		throw new IllegalArgumentException();
	}
}

public class Client {

	public static void main(String[] args) {

		Report report = new Report("admin or durga");
		PermissionExpressionBuilder builder = new PermissionExpressionBuilder();
		PermissionExpression expression = builder.build(report);

		User user = new User(Collections.singletonList("durga"));
		System.out.println(expression.interpret(user));
	}
}

Write a note on design consideration for interpreter design pattern?

-	Additional operation such as pretty printing can be included.

-	There is no specific convention for parsing and building syntax tree.

-	Context object can save and access the state of expression.

-	We may use visitor design pattern instead of using interpret method inside expression class.

-	We can use flyweight design pattern for terminal operation.

-	The terminal operation can be reused.

Write a note on pitfalls of interpreter design pattern?

-	Class per rule will result into large number of classes.

-	Interpreter design pattern is not suitable for language with complex grammar rule.

-	It is used to address a particular problem like interpreting language only.

Explain the mediator design pattern?

-	The mediator design pattern is a behavioral design pattern.

-	It encapsulates how set of objects interact with each other.

-	The interaction is encapsulated inside the mediator object and interacting objects only know about it.

-	There is a loose coupling between interacting objects.

-	Interaction can now change without changing the participant objects.

-	Changing the mediator allows to add or remove participants in an interaction. 

Write a note on implementing mediator design pattern?

-	Define mediator class.

-	Define method which will be called by participant object to inform its state change.

-	The method must know which data member or participant object is changed.

-	Implement method to interactwith participant objects and inform them about the state changed.

-	Mediator needs to know the participant objects, it can create them or they can register with it.

-	Handle infinite loop resulting from change notify change.

Write a note on design consideration for mediator design pattern?

-	Mediator must identify which participant object's state is changed and must not inform it about the same.

-	If a participant object requires too long to process the state change of another participant object then it may impact the overall performance of mediator.

-	We can extend the mediator and create different possibilities of interactions under different situations.

-	Having abstract mediator instead of concrete is not always required.

-	We can use observer design pattern through which participant objects will inform the mediator about their state change.

							|---------------------------
							|						   |	
							|		<<interface>>      |  	  <<concrete class>>
		  Client			|		UIControl	 	   |	  UIMediator								
		  ---------------	|		---------------	   |	  -------------            					
		  | 		    |---------->|		      |--  ------>| 		  |            
		  ---------------			---------------	|	  	  -------------
									 ^	  	     ^	|				<>
									---         --- |----------------|				 
									 .	  	     .
									 .           .
							------------- 	   -------------
	    Label				|	   		|	   |		   | 	Slider 
	    <<concrete class>>	-------------      ------------- 	<<concrete class>>


Example:

public interface UIControl {

	void controlChanged(UIControl control);

	String getValue();
}

public class Label implements UIControl {

	private UIMediator mediator;

	private String value;

	public Label(UIMediator mediator) {
		this.mediator = mediator;
		mediator.register(this);
	}

	@Override
	public void controlChanged(UIControl control) {
		this.value = control.getValue();
	}

	@Override
	public String getValue() {
		return value;
	}
}

public class Slider implements UIControl {

	private UIMediator mediator;

	private String value;

	public Slider(UIMediator mediator) {
		this.mediator = mediator;
		mediator.register(this);
	}

	@Override
	public void controlChanged(UIControl control) {
		this.value = control.getValue();
	}

	@Override
	public String getValue() {
		return value;
	}
}

public class UIMediator {

	private List<UIControl> participants;

	public UIMediator() {
		participants = new ArrayList<>();
	}

	public void register(UIControl control) {
		participants.add(control);
	}

	public void valueChanged(UIControl control) {
		participants.stream().filter(participant -> participant != control)
				.forEach(participant -> participant.controlChanged(control));
	}
}

Write a note on pitfalls of mediator design pattern?

-	Difficult to maintainas mediator complexity grows.

-	Difficult to implement as reusable mediator.

Explain the iterator design pattern?

-	The iterator design pattern is a behavioral design pattern.

-	It allows to access elements of an aggregate object in sequence while hiding the internal data structure.

-	Iterator is stateful i.e. it remembers its position while iterating.

-	It becomes out of sync if underlying aggregate object is changed.

Write a note on implementing iterator design pattern?

-	Declare iterator interface.

-	Implement the iterator as inner class inorder to access tthe elements of aggregate object.

-	Maintain the state to know the position inside the elements aggregate object.

-	Throw exception if aggregate object is changed while iterating.

									   
		  Client					Iterator <<interface>>	 	 						
		  ---------------			---------------				
		  | 		    |---------->|		      |  
		  ---------------			---------------	
									 ^	  
									---   
									 .	  
									 .    
							-------------			------------- 
	    ThemeColorIterator	|	   		|--------(+)|	   		|	ThemeColor
	    <<concrete class>>	-------------		    -------------	<<concrete class>>

Example:

public interface Iterator {

	boolean hasNext();

	String next();
}

public class ThemeColor {

	private String[] colors;

	public ThemeColor() {
		colors = new String[] { "Red", "Green", "Blue", "Pink" };
	}

	public Iterator getIterator() {
		return new ThemeColorIterator();
	}

	private class ThemeColorIterator implements Iterator {

		private int position;

		@Override
		public boolean hasNext() {
			return position < colors.length;
		}

		@Override
		public String next() {
			return colors[position++];
		}

	}
}

public class Client {

	public static void main(String[] args) {

		ThemeColor themeColor = new ThemeColor();
		Iterator iterator = themeColor.getIterator();

		while (iterator.hasNext()) {
			System.out.println(iterator.next());
		}
	}
}

Write a note on design consideration for iterator design pattern?

-	Identifying changes to underlying aggregate object while client is using iterator is important.

-	Iterator implementation as inner class is recommended as it makes it easy to access elements of aggregate object.

-	Use iterator interface and hide the implementation from the client.

-	Iterator can be used in use cases without collection as well.

Write a note on pitfalls of iterator design pattern?

-	Access to index isn't available to client while iterating.

-	Changes to the aggregate object makes iterator invalid.

Explain the memento design pattern?

-	The memento design pattern is a behavioral design pattern.

-	It allows to save the object's state (originator) without exposing exposing the internal details.

-	We can restore the object's state to previously saved state.

-	The object can return its state as a sealed object which doesn't allow state modification.

-	It is used along with command design pattern to provide the undo functionality.

Write a note on implementing memento design pattern?

-	Find the originator state which needs to be saved.

-	Memento must not be allowed to be changed and read outside originator.

-	The originator class must provide method which records snapshot and provides object of memento.

-	Also another method to restore the originator state to memento state.

																														<<interface>>
		  Client																										Command	    						
		  ---------------																								---------------				
		  | 		    |---------------------------------------------------------------------------------------------->|		      |  
		  ---------------								|																---------------	
														|																	   ^	  
														|																	  ---
														|																	   .				   
														|																	   .	  
														V																	   .    
							-------------			------------- 						-------------					---------------   
	    Memento				|	   		|--------(+)|	   		|<*>--------------------|		    |				    |		      |		AddWorkflowCommand	
	    <<concrete class>>	-------------		    -------------	  					-------------   	        	---------------		<<concrete class>>
                                  |                       | 	WorkflowDesigner        Workflow    						  <*>	 
                                  |                       |     <<concrete class>>      <<concrete class>>        			   |
							      |						  |																	   |
								  ----------------------------------------------------------------------------------------------

Example:

public class Workflow {

	private String name;

	private LinkedList<String> steps;

	public Workflow(String name, LinkedList<String> steps) {
		this.name = name;
		this.steps = new LinkedList<>(steps);
	}

	public String getName() {
		return name;
	}

	public LinkedList<String> getSteps() {
		return steps;
	}
}

public class WorkflowDesigner {

	private Workflow workflow;

	public WorkflowDesigner(String name) {
		this.workflow = new Workflow(name, new LinkedList<String>());
	}

	public Memento geMemento() {
		return new Memento(workflow.getName(), workflow.getSteps());
	}

	public void setMemento(Memento memento) {
		this.workflow = new Workflow(memento.getName(), new LinkedList<String>(memento.getSteps()));
	}

	public void addStep(String step) {
		workflow.getSteps().add(step);
	}

	public void show() {
		System.out.println(workflow.getSteps());
	}

	public class Memento {

		private String name;

		private LinkedList<String> steps;

		private Memento(String name, LinkedList<String> steps) {
			this.name = name;
			this.steps = new LinkedList<>(steps);
		}

		private String getName() {
			return name;
		}

		private LinkedList<String> getSteps() {
			return steps;
		}
	}
}

public interface WorkflowCommand {

	public void execute();

	public void undo();
}

public class AddWorkflowCommand implements WorkflowCommand {

	private WorkflowDesigner orignator;

	private WorkflowDesigner.Memento memento;

	private String step;

	public AddWorkflowCommand(WorkflowDesigner orignator, String step) {
		this.orignator = orignator;
		this.step = step;
	}

	@Override
	public void execute() {
		this.memento = orignator.geMemento();
		orignator.addStep(step);
	}

	@Override
	public void undo() {
		orignator.setMemento(memento);
	}
}

public class Client {

	public static void main(String[] args) {

		WorkflowDesigner orignator = new WorkflowDesigner("Leave workflow");

		WorkflowCommand command1 = new AddWorkflowCommand(orignator, "Create Leave Application");
		WorkflowCommand command2 = new AddWorkflowCommand(orignator, "Submit Leave Application");
		WorkflowCommand command3 = new AddWorkflowCommand(orignator, "Leave Application Approved");

		command1.execute();
		command2.execute();
		command3.execute();

		orignator.show();
		command3.undo();
		orignator.show();
	}
}

Write a note on design consideration for memento design pattern?

-	Be careful about the size of memento state. One solution is to discard older saved states.

-	The memento class must be inner class to originator class to ensure it is read only by originator.

-	Restoring to a previous state must consider the effect on the state of another objects.

-	If there is a definite fixed way in which mementos are created (using command design pattern) then only delta states can be saved. 

-	Memento encapsulated inside originator might increase the implementation complexity.

Write a note on pitfalls of memento design pattern?