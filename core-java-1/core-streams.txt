core java - streams

Why should we use stream?

-	In java stream allows to use declarative programming instead of imperative programming.

-	The implementation of stream operation is managed by programming language and must not be taken care by developer.

-	This will ensures that code is concise.

How is stream is different from collection?

-	The purpose of collection is to store elements. 

-	But the purpose of stream is to process elements.

-	Any operation on stream do not modify the collection.

-	The stream operations are lazy in nature.

-	Elements of stream can be consumed only once.

-	A stream can produce infinite number of elements i.e stream is unbounded.

How to create stream?

-	To create stream from array we need to use method with name of from Stream interface.

	Example:
	
	Stream strm = Stream.of(10, 20, 30, 40, 50);

-	To create stream from collection we need to use method with name stream from Collection interface.

	Example:
	
	Stream strm = lst.stream();

What is an unbounded stream?

-	A stream which can produce infinite number of elements is called unbounded stream.

-	There are two ways to produce infinite stream.

-	First way is to use generate method which accept supplier object as an input arguement. 

	Syntax:
	
	public Stream generate(Supplier sup)

	Example:

	Stream.generate(Math::random).forEach(System.out::println);

-	Next way is to use iterate method which accept initial seed or value and UnaryOperator.

-	It will produce infinite elements by calling unary operator first time using the initial seed value to produce new seed.

-	Then new seed value is passed as arguement to unary operator everytime.

	Syntax:
	
	public Stream iterate(T seed, UnaryOperator uop)

	Example:

	Stream.iterate(10, num1 -> num1 + 10).forEach(System.out::println);

What are stream operations?

-	There are two types of stream operations they are called as intermediate and terminal operations.

-	Intermediate operations exist between the source or stream and the terminal operation.

-	They result into new stream.

-	These operations are lazy in nature.

-	Intermediate operation can further divided into stateless and statefull operations.

-	In stateless operations the processing of each element is independent of another.

	Example:
	
	Filter, Map

-	But in statefull operations processing of each element is dependent on another.

	Example:
	
	Distinct, Sort

-	Terminal operations produce final result of processing and not another stream.

-	They are eager in nature.

-	After the terminal operation the stream pipeline is consumed.
	
Enlist some intermediate stream operation?

-	Filtering operation is similar to WHERE clause inside SQL SELECT query. 
	
-	It is stateless operation.	
	
	Syntax:
	
	public Stream filter(Predicate pred)
	
-	Mapping operation is similar to column names (*) inside SQL SELECT query. 

-	It is stateless operation.	

	Syntax:
	
	public Stream map(Function f)	
	
-	Sorting operation is similar to ORDER BY clause inside SQL SELECT query.

-	It is a statefull operation.

	Syntax:
	
	public Stream sorted(Comparator cmp)
	
Enlist some terminal stream operation?

-	Maximum operation is similar to MAX function inside SQL SELECT query. 	
	
	Syntax:
	
	public T max(Comparator cmp)
	
-	Minimum operation is similar to MIN function inside SQL SELECT query. 	
	
	Syntax:
	
	public T min(Comparator cmp)	

-	All match, Any match and None match operations are similar to EXISTS clause inside SQL SELECT query.

	Syntax:
	
	public boolean allMatch(Predicate pred)
	
	public boolean anyMatch(Predicate pred)
	
	public boolean noneMatch(Predicate pred)

Explain what is Collectors?

-	Collectors is a helper class.

-	It provides various reduction method.

-	It allows to collect and store elements of stream inside new collection.

	Example:
	
	List lst = strm.collect(Collectors.toList());

-	We can also sum, average and group by the elements of stream.

	Example:

	double sum = strm.collect(Collectors.summingDouble(Employee::getSalary)));
	
	Example:

	double avg = strm.collect(Collectors.averagingDouble(Employee::getSalary)));

	Example:
	
	Map<Department, Double> deptWiseSal = strm.collect(Collectors.groupingBy(Employee::getDepartment, Collectors.summingDouble(Employee::getSalary)));

What are parallel streams?

-	By default all non-terminal and terminal stream operation are executed sequentially by single thread.
-	But we can explicitly cause these operations to be executed by simultaneously by multiple threads using parallel streams.

-	Parallel streams must be used only when operations on collection or array elements is stateless.

-	To create parallel streams we have two ways,

	a) By invoking following method on collection object,
	
		public Stream<R> parallelStream()
	
	b) By invoking following method on stream object;
		
		public Stream<R> parallel()
	
	Example:	
	{
		List<String> l1 = new ArrayList<String>();
		l1.add("java");l1.add("c++");l1.add("python");
		l1.add("html");l1.add("css");l1.add("js");
		
		l1.parallelStream().forEach(System.out::println);	/**css html c++ java js python**/
	}

What are infinite streams?

-	Terminal operation that can perform never ending data computation and add computed data to output stream, such streams are called infinite streams.
-	To create infinite streams we have two ways,
	
	a) By invoking following method of Stream class,
	
		public static Stream<R> generate(Supplier<R> s)
		-	Here stream will have same data repeatedly returned by supplier.
	
	Example:
	{
		Stream.generate(() -> 10)
		.forEach(System.out::println);		/**10 10 10 10 10...**/
	}		
	
	b) By invoking following method of Stream class,
	
	   public static Stream<R> iterate(T t, UnaryOperator<R> s)
	   -	Here stream will compute data with initial value t and unary operator.
	  
	Example:
	{
		Stream.iterate(10, i -> i + 10)
		.forEach(System.out::println);		/**10 20 30 40 50...**/
	}

What is stream reduction?

-	Reducing a stream means combining data elements computed by non-terminal operations to single element at terminal.
-	To reduce stream we have one ways,
	
	a) By invoking following method on stream object,
	
		public Stream<R> reduce(T t, BinaryOperator<R> s)
		-	Here stream will compute single data with initial value t and binary operator.
	  
	Example:
	{
		Stream.of(10, 20, 30, 40, 50).reduce(0, (a, b) -> a + b);		/**150**/
	}		

What are primitive streams?

-	To avoid frequent boxing and unboxing primitive streams are available in java.
-	Following are different primitive streams in java,

	a) java.util.stream.IntStream
	-	IntStream is a stream of primitive int elements.	
	-	IntStream primitive interfaces provides following static methods for creating stream,

		public static IntStream range(int s, int e)
		-	It returns a stream from s to e - 1, if s >= e then returns empty stream.  	
		
		public static IntStream rangeClosed(int s, int e)
		-	It returns a stream from s to e, if s > e then returns empty stream.  	

	b) java.util.stream.LongStream
	-	LongStream is a stream of primitive long elements.
	-	LongStream primitive interfaces provides following static methods for creating stream,

		public static LongStream range(int s, int e)
		-	It returns a stream from s to e - 1, if s >= e then returns empty stream.  	
		
		public static LongStream rangeClosed(int s, int e)
		-	It returns a stream from s to e, if s > e then returns empty stream.  	

	c) java.util.stream.DoubleStream
	-	DoubleStream is a stream of primitive double elements.
	-	DoubleStream primitive interfaces provides following static methods for creating stream,

		public static DoubleStream range(int s, int e)
		-	It returns a stream from s to e - 1, if s >= e then returns empty stream.  	
		
		public static DoubleStream rangeClosed(int s, int e)
		-	It returns a stream from s to e, if s > e then returns empty stream.  	

	Example:
	{
		IntStream.rangeClosed(10, 15);	/**10 11 12 13 14 15**/
	}