core java - time complexity in java

What is time complexity?

-	Time Complexity measures the time taken for running an algorithm.
-	It counts the number of elementary operations performed by the algorithm.

Consider a polygon scenario(not an rectangle) scenario,

  .A  ____________3km_______________ .B
	 |								|
  2km|								|2km	
	 |								|			
  .C |______________________________|.D
				  5km	 
-	To reach point D from point A,

a) Person X suggest,
	Route = A-C-D
	Distance = 7km
	Time = 20 mins
	
a) Person Y suggest,
	Route = A-B-D
	Distance = 5km
	Time = 15 mins
	
a) Person Z suggest,
	Route = A-D
	Distance = 3 km
	Time = 12 mins

What is asymptotic analysis?

-	It is the method of computing best(Z's suggestion), average(Y's suggestion) and worst(X's suggestion) behavior of any programming operation.
-	In asymptotic analysis these measurements have some notations,
	
	a) Big Oh O(---) = worst case time complexity
	b) Theta Theta(---) = average case time complexity
	c) Omega Omega(---) = best case time complexity

Which are different possible worst case time complexities?

-	Following are different possible worst case time complexities,

a)	O(1)

-	In this case only single elementary step is involved irrespective of size of input.
-	For example, 
	i) Adding first 2 elements in array requires a single step operation irrespective of number of elements present in array,
	   this gives time complexity of O(1).
		{
			int sum = arr[0] + arr[1];
		}
	
	ii)	In java.util.HashMap, and java.util.LinkedHashMap class the time complexity of get(key) and put(key, value) is O(1),
		as single step of computing hash code or bucket location and finding element in that bucket is involved.

	iii)In java.util.HashSet, and java.util.LinkedHashSet class the time complexity of add(value) is O(1),
		as single step of computing hash code or bucket location and finding element in that bucket is involved.

	iv)	In java.util.ArrayList class for add(value) and get(idx) time complexity is O(1) as internal data structure is array
		and it supports random access.
		
	v)	In java.util.LinkedList class for add(value) time complexity is O(1) as internally liked list maintains pointer to last element, after which new
		element is added and pointer points to new element.
		
b)  O(n * log n)

-	In this case, the input is divided into sub parts and operation is performed on sub parts.
-	Later sub parts are merged to form final output and time complexity is O(n * log n).
-	For example, Merge sort.
	
c)  O(log n)

-	In this case, the input is divided into sub parts and operation is performed on sub parts.
-	In this case number of elementary step is involved reduces and time complexity is O(log n).
-	For example, 
	i)	Finding element in sorted array using binary search algorithm, this gives time complexity of O(log n).
	{
		int[] arr = {10, 25, 50, 70, 90};
		
		int s = 0;
		int m = 0;
		int e = arr.length - 1;
		while(s <= e) {
			m = (s + e) / 2;
			if(arr[m] == 25) {
				break;
			}else if(arr[m] > 25) {
				e = m - 1;
			}else {
				s = m + 1;
			}
		}
	}
	ii) In java.util.TreeMap class the time complexity of get(key) and put(key, value) is O(log n), as it involves traversing internal binary search tree
		deciding on basis of each node value whether required value is on left branch or right to that node.

	iii)In java.util.TreeSet class the time complexity of get(key) and add(value) is O(log n), as it involves traversing internal binary search tree
	deciding on basis of each node value whether required value is on left branch or right to that node.

d)  O(n)

-	In this case number of elementary step is involved is equals to the size of input.
-	For example, 
	i) Finding element = 10 in an array of size 20 will require maximum 20 iterations, this gives time complexity of O(n).
		{
			for(int i = 0; i < 20; i++) {
				if(arr[i] == 10){
					break;
				}
			}
		}
		
	ii)	In java.util.ArrayList class for add(idx, value) time complexity is O(n) as internal data structure is array
		so it requires iterating to idx index, adding new element at idx index and shifting elements to right after idx + 1 index position is required.
	
	iii)In java.util.ArrayList class for remove(ele) time complexity is O(n) as internal data structure is array
		so it requires requires iterating to idx index(assume idx index holds ele), removing element at idx index shifting 
		elements to left before idx - 1 index position is required.

e)	O(n^2)

-	In this case number of elementary step is involved is equals to the square of size of input.
-	For example, 
	i) Sorting an array of size 20 using bubble sort, for every outer loop iterating once inner loop iterates maximum 20 times,
	   this gives time complexity of O(n^2).
		{
			for(int i = 0; i < 20; i++) {
				for(int j = i + 1; j < 20; j++) {
					if(arr[j] < arr[i]){
						temp = arr[j];
						arr[j] = arr[i];
						arr[i] = temp;
					}
				}
			}
		}
	
	
Explain time complexities for different collections?

Collections				add(ele)/put(key, val)		get(idx)/get(key)		contains(ele)/containsKey(key)		remove(ele)/remove(key)

ArrayList						O(1)					O(1)						O(n)								O(n)
LinkedList						O(1)					O(n)						O(n)								O(n)

HashSet							O(1)					O(1)						O(1)								O(1)
HashMap							O(1)					O(1)						O(1)								O(1)

LinkedHashSet					O(1)					O(1)						O(1)								O(1)
LinkedHashMap					O(1)					O(1)						O(1)								O(1)		

TreeSet							O(log n)				O(log n)					O(log n)							O(log n)
TreeMap							O(log n)				O(log n)					O(log n)							O(log n)
	