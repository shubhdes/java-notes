spring boot-kubernetes

What is kubernetes?

-	Kubernetes is server manager which manages servers in cloud.

-	Kubernetes calls these servers as nodes.

-	There are two types of nodes master node and worker node.

-	These two types of nodes together are called as cluster.

-	The master node is responsible to manage one or more worker nodes.

-	The worker node is responsible to run our application.

-	Kubernetes follow once concept one responsibility principle.

-	It provides auto-scaling, service discovery, load balancing, self-healing and zero downtime.

How to execute kubernetes commands?

-	To execute kubernetes commands we need to connect to cluster first.

-	In google cloud click on the cluster hyper link to open cluster details in new browser window.

-	In this window on top right hand side select icon that says activate cloud shell.

-	We can open cloud shell in new browser window by using new window icon on top right hand side of the cloud shell window.

-	Again in the cluster browser window on top right hand side click icon which says connect and copy the command from prompt window.

-	Paste this command in cloud shell window in new browser window and press enter.

	Syntax:
	
	#gcloud container clusters get-credentials [name] --zone [name] --project [name]
	
	Example:
	
	#gcloud container clusters get-credentials shubhdes-1 --zone us-central1-a --project solid-course-258105

-	This will connect you to the kubernetes cluster.

-	All kubernetes commands require kubectl binary to be installed, in google cloud shell this binary is already installed.

-	The word kubectl stands for kubernetes controller. 

	Example:
	
	#kubectl --version
	
How to deploy an application using kubernetes?

-	To deploy docker image into cluster we need to use the following command.

-	This command will require the docker image to be present inside the docker hub.

	Syntax:

	#kubectl create deployment [name] --image=[name]

	Example:

	#kubectl create deployment my-app --image=shubhdes/my-app:1.0

-	Once the deployment is completed it is necessary to expose it to external system using the following command.

-	External system will be using the deployed application.	

	Syntax:
	
	#kubectl expose deployment [name] --type=[type] --port=[port]
	
	Example:
	
	#kubectl expose deployment my-app --type=LoadBalancer --port=8080
	
What is a pod in kubernetes?

-	In kubernetes smallest deployable unit is pod.

-	One or more containers live inside a pod.

-	One or more pods live inside a node.

-	To view all available pods inside cluster we need to use following command.

	Example:

	#kubectl get pods

-	To view all details of specific pod inside cluster we need to use following command.

	Syntax:

	#kubectl describe pod [name]	
	
	Example:

	#kubectl describe pod my-app-12sbeha-206yh

-	To remove a running pod	inside cluster we need to use following command.

	Syntax:

	#kubectl delete pod [name]	
	
	Example:

	#kubectl delete pod my-app-12sbeha-206yh 
	
What is a replicaset in kubernetes?

-	In kubernetes replicaset ensures that specific number of pods are always running.

-	We can set the minimum number of pod instance that must be running at any given time using following command.

	Syntax:

	#kubectl scale deployment [name] --replicas=[n]
	
	Example:

	#kubectl scale deployment my-app --replicas=3

What is a deployment in kubernetes?

-	Consider we have a deployment that is running an image of my-app version 1.0.

-	To deploy an image of same my-app with version 2.0 we need to undeploy the image with version 1.0.

-	We need to ensure that we have total zero downtime during this undeployment and redeployment.

-	To set new image to an existing deployment we need to use the following command.

	Syntax:

	#kubectl scale deployment my-app --image=[container=image] 
	
	Example:

	#kubectl scale deployment my-app --image=my-app=shubhdes/my-app:2.0
	
-	Everytime deployment is created or update a new replicaset is created.

-	When deployment is updated and replicaset of new deployment has one pod running then replicaset of older deployment removes one pod.

-	Also when replicaset of new deployment has second pod running then replicaset of old deployment will scale down second pod.

-	In this manner replicaset of old deployment removes all pods when replicaset of new deployment has all pods running.

-	This deployment startegy is called rolling update.

-	But when the deployment is updated and it is failed the replicaset of older deployment continue to work.

-	This will ensure total zero downtime during this undeployment and redeployment.

What is a service in kubernetes?

-	A service allows cluster to receive traffic through permanantly available interface.

-	Pods are throw away units in kubernetes.

-	They are created and destroyed dynamically hence thier IP address will change frequently.

-	Service has permanant IP address which accept the incoming traffic and redirect it to pods.

-	Service can show different behavior and perform different activities based on the service type specified at the time of deployment.

	Syntax:
	
	#kubectl expose deployment [name] --type=[type] --port=[port]
	
	Example:
	
	#kubectl expose deployment my-app --type=LoadBalancer --port=8080

What are events in kubernetes?

-	Whenver an deployment, pod, replicaset and service is created or updated or deleted these actions are called as events.

-	To view all events that were generated in kubernetes we need to use the following command.

	Example:
	
	#kubectl get events
	
-	We can also sort the events by timestamp of their occurence using the following command.

	Example:
	
	#kubectl get events --sort-by=.metadata.creationTimestamp
	
What are different components of master node?

-	The master node has four components called as distributed database, api-server, scheduler and controller manager.

-	The distributed database is called etcd.

-	All kubernetes desired state i.e. commands executed to change the state of cluster are stored in etcd.

-	The api-server is called as kube api-server.

-	It is an interface between the cloud shell window and kubernetes engine.

-	The scheduler is called kube scheduler.

-	It is responsible to make decision on which node new pod will be created.

-	The controller manager is alse called as kube controller manager.

-	It is responsible to monitor the health of the cluster.

-	It ensures that actual state of kubernetes cluster matches desired state from distributed database.

What are different components of worker node?

-	The worker node has four components called as node agent, networking component, container runtime and pods.

-	The node agent is called kubelet.

-	It monitors the node and send information to controller manager of master node.

-	One of its activities is to monitor running pods and inform the controller manager of master node when a pod becomes unavailable.

-	The networking component is called kube proxy.

-	It helps in creating services i.e permanant interface around pods.

-	The container runtime is docker container which run inside a pod.

-	The worker node can contain one or more pods.

-	Applications run inside pods.

How to deploy microservices in kubernetes?

-	Kubernetes provides service discovery, api gateway and log management features.	

-	Therefore we need to remove the following dependencies from maven pom.xml of the microservices project.

	Example:
	
	<!-- naming server-->
	<dependency>
		<groupId>org.springframework.cloud</groupId>
		<artifactId>spring-cloud-starter-netflix-eureka-server</artifactId>
	</dependency>
	
	<!-- naming client-->
	<dependency>
		<groupId>org.springframework.cloud</groupId>
		<artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
	</dependency>
	
	<!-- api gateway-->
	<dependency>
		<groupId>org.springframework.cloud</groupId>
		<artifactId>spring-cloud-starter-netflix-zuul</artifactId>
	</dependency>
	
	<!-- zipkin -->
	<dependency>
		<groupId>org.springframework.cloud</groupId>
		<artifactId>spring-cloud-sleuth-zipkin</artifactId>
	</dependency>
	
	<!-- rabbit mq-->
	<dependency>
		<groupId>org.springframework.ampq</groupId>
		<artifactId>spring-rabbit</artifactId>
	</dependency>
	
-	By default kubernetes will create environment variable for each microservice at time of deployment.

-	The value of this variable will be instance information of pod running docker container for microservice.

-	When microservice name is my-app-ms1 then kubernetes will create environment variable with name MY_APP_MS1_SERVICE_HOST.

-	Next step we need to update annotation of feign proxy to use kubernetes created environment variable.

	Example:
	
	@FeignClient(name = "my-app-ms1", url = "${MY_APP_MS1_SERVICE_HOST}:8080")

How to use yaml configuration to deploy microservices in kubernetes?

-	When deployment in kubernetes is done using yaml file is called declarative approach for deployment.

-	Copy the yaml file of existing deployment using the below command.

	Syntax:
	
	#kubectl get deployment [name] -o yaml >> [file]
	
	Example:
	
	#kubectl get deployment my-app-ms1 -o yaml >> deployment.yaml
	
-	Copy the yaml file of existing service using the below command.

	Syntax:
	
	#kubectl get service [deployment name] -o yaml >> [file]
	
	Example:
	
	#kubectl get service my-app-ms1 -o yaml >> service.yaml
	
-	Append the contents of service.yaml to the contents of deployment.yaml.	

-	Update deployment.yaml as required.

-	Delete the existing deployment of the microservice using the following command.

	Syntax:
	
	#kubectl delete all -l [label]=[value]
	
	Example:
	
	#kubectl delete all -ll app=my-app-ms1
	
-	Deleting deployment is optional otherwise kubernetes will update existing deployment.	

-	Create or update the existing deployment using following command.

	Syntax:
	
	#kubectl apply -f [file]
	
	Example:
	
	#kubectl apply -f deployment.yaml
	
Why is it recommended to not use kubernetes created environment variable?

-	The kubernetes will create environment variable for each microservice. 

-	Consider a situation where we have two microservices my-app-ms1 and my-app-ms2.

-	The microservice my-app-ms1 makes a web request to my-app-ms2.

-	However while deployment the my-app-ms1 is deployed first an hence there is no environment variable of my-app-ms2.

-	Even when later my-app-ms2 is deployed the environment variable is not made available to my-app-ms1.

-	When microservice my-app-ms1 will call my-app-ms2 the web request will fail with runtime exception.

-	Hence it is recommended to use custom environment variable instead of kubernetes created environment variable.

-	We can pass this environment variable to container of my-app-ms1 microservice in deployment.yaml.

	Syntax:
	
	env:
	  - name: [name]
	    value: http://[permanant service]

	Example:
	
	env:
      - name: MY_APP_MS2_URI
        value: http://my-app-ms2
 	
What is config map in kubernetes?

-	In kubernetes config map allows us to store configurations for multiple microservices across multiple deployments in single place.

-	Create config map for our deployment using following command.

	Syntax:
	
	#kubectl create configmap [name] --from-literal=[name]=[value]
	
	Example:
	
	#kubectl create configmap my-app-ms1-cm --from-literal=MY_APP_MS2_URI=http://my-app-ms2

-	Copy the yaml file of existing config using the below command.

	Syntax:
	
	#kubectl get configmap [name] -o yaml >> [file]
	
	Example:
	
	#kubectl get configmap my-app-ms1-cm -o yaml >> configmap.yaml
	
-	Append the contents of configmap.yaml to the contents of deployment.yaml.	

-	Change the container configuration in deployment.yaml to use config map.

	Syntax:
	
	envFrom:
	  - configMapRef:
	      name: [name]

	Example:
	
	envFrom:
	  - configMapRef:
	      name: my-app-ms1-cm

-	Update deployment.yaml as required.

-	Create or update the existing deployment using following command.

	Syntax:
	
	#kubectl apply -f [file]
	
	Example:
	
	#kubectl apply -f deployment.yaml
	
How kubernetes maintains deployment history?

-	In kubernetes complete deployment history is maintained.

-	To find out the history of kubernetes deployment we need to use following command.

	Syntax:

	#kubectl rollout history deployment [name]

	Example:

	#kubectl rollout history deployment my-app-ms1

-	In case if the deployment fails we can undo deployment and rollback the desired state to previous successfull deployment.

	Syntax:

	#kubectl rollout undo deployment [name] --to-revision=[n]

	Example:

	#kubectl rollout undo deployment my-app-ms1 --to-revision=2
	
What are probes?

-	When we change deployment from one version to another there is some amount of downtime.

-	This is because when deployment on new pod is successfull then kubernetes immediately terminate the old pod.

-	However spring boot application running in new pod will take some time to start after deployment.

-	This time duration will bring downtime.

-	We can avoid this downtime using probes.

-	Kubernetes uses two types of probes called readiness and liveness probes.

-	When the readiness probes fails then no web request is forwarded to pod.

-	When the liveness probe fails then the pod is restarted. 	

-	In spring boot (version >= 2.3) these probes are provided by the actuator hence it is necessary to include following dependency in pom.xml.

	Example:
	
	<dependency>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter-actuator</artifactId>
	</dependency>

-	The readiness probe is available on /actuator/heath/readiness endpoint.

-	The liveness probe is available on /actuator/heath/liveness endpoint.

-	We can use these probes in deployment and we need to configure them in deployment.yaml file under containers section.

	Example:
	
	readinessProbe:
	  httpGet:
	    port: 8000
		  path: /actuator/heath/readiness
	livenessProbe:
	  httpGet:
	    port: 8000
		  path: /actuator/heath/liveness		 

How to auto-scale microservices instance in kubernetes?

-	We can increase number of pods running our microservice application using scale command or by modifying deployment.yaml file.

-	However this process is manual.

-	Kubernetes supports with auto-scale feature wherein kubernetes itself will increase number of pods if certain condition is met.

-	To enable auto-scaling in kubernetes when the cpu usage exceeds over certain limit we need to use following command.

	Syntax:

	#kubectl autoscale deployment [name] --min=[n1] --max=[n2] --cpu-percent=[n3]

	Example:

	#kubectl autoscale deployment my-app-ms1 --min=1 --max=2 --cpu-percent=70

-	This is called horizontal pod auto-scaler.

-	We can delete this horizontal pod auto-scaler by using the following command.

	Syntax:

	#kubectl delete hpa [name]

	Example:

	#kubectl delete hpa my-app-ms1
	
How to delete cluster in kubernetes?

-	In google cloud near to the cluster hyper link select the delete icon, this will delete your entire cluster.
	