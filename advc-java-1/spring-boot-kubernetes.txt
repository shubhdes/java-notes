spring boot-kubernetes

What is kubernetes?

-	Kubernetes is server manager which manages servers in cloud.

-	Kubernetes calls these servers as nodes.

-	There are two types of nodes master node and worker node.

-	These two types of nodes together are called as cluster.

-	The master node is responsible to manage one or more worker nodes.

-	The worker node is responsible to run our application.

-	Kubernetes follow once concept one responsibility principle.

-	It provides auto-scaling, service discovery, load balancing, self-healing and zero downtime.

How to execute kubernetes commands?

-	To execute kubernetes commands we need to connect to cluster first.

-	In google cloud click on the cluster hyper link to open cluster details in new browser window.

-	In this window on top right hand side select icon that says activate cloud shell.

-	We can open cloud shell in new browser window by using new window icon on top right hand side of the cloud shell window.

-	Again in the cluster browser window on top right hand side click icon which says connect and copy the command from prompt window.

-	Paste this command in cloud shell window in new browser window and press enter.

	syntax:
	
	#gcloud container clusters get-credentials [name] --zone [name] --project [name]
	
	example:
	
	#gcloud container clusters get-credentials shubhdes-1 --zone us-central1-a --project solid-course-258105

-	This will connect you to the kubernetes cluster.

-	All kubernetes commands require kubectl binary to be installed, in google cloud shell this binary is already installed.

-	The word kubectl stands for kubernetes controller. 

	example:
	
	#kubectl --version
	
How to deploy an application using kubernetes?

-	To deploy docker image into cluster we need to use the following command.

-	This command will require the docker image to be present inside the docker hub.ss

	syntax:

	#kubectl create deployment [name] --image=[name]

	example:

	#kubectl create deployment my-app --image=shubhdes/my-app:1.0

-	Once the deployment is completed it is necessary to expose it to external system using the following command.

-	External system will be using the deployed application.	

	syntax:
	
	#kubectl expose deployment [name] --type=[type] --port=[port]
	
	example:
	
	#kubectl expose deployment my-app --type=LoadBalancer --port=8080
	
What is a pod in kubernetes?

-	In kubernetes smallest deployable unit is pod.

-	One or more containers live inside a pod.

-	One or more pods live inside a container.

-	To view all available pods inside cluster we need to use following command.

	example:

	#kubectl get pods

-	To view all details of specific pod inside cluster we need to use following command.

	syntax:

	#kubectl describe pod [name]	
	
	example:

	#kubectl describe pod my-app-12sbeha-206yh

-	To remove a running pod	inside cluster we need to use following command.

	syntax:

	#kubectl delete pod [name]	
	
	example:

	#kubectl delete pod my-app-12sbeha-206yh 
	
What is a replicaset in kubernetes?

-	In kubernetes replicaset ensures that specific number of pods are always running.

-	We can set the minimum number of pod instance that must be running at any given time using following command.

	syntax:

	#kubectl scale deployment [name] --replicas=[n]
	
	example:

	#kubectl scale deployment my-app --replicas=3

What is a deployment in kubernetes?

-	Consider we have a deployment that is running an image of my-app version 1.0.

-	To deploy an image of same my-app with version 2.0 we need to undeploy the image with version 1.0.

-	We need to ensure that we have total zero downtime during this undeployment and redeployment.

-	To set new image to an existing deployment we need to use the following command.

	syntax:

	#kubectl scale deployment my-app --image=[container=image] 
	
	example:

	#kubectl scale deployment my-app --image=my-app=shubhdes/my-app:2.0
	
-	Everytime deployment is created or update a new replicaset is created.

-	When deployment is updated and replicaset of new deployment has one pod running then replicaset of older deployment removes one pod.

-	Also when replicaset of new deployment has second pod running then replicaset of old deployment will scale down second pod.

-	In this manner replicaset of old deployment removes all pods when replicaset of new deployment has all pods running.

-	This deployment startegy is called rolling update.

-	But when the deployment is updated and it is failed the replicaset of older deployment continue to work.

-	This will ensure total zero downtime during this undeployment and redeployment.

What is a service in kubernetes?

-	A service allows cluster to receive traffic through permanantly available interface.

-	Pods are through away units in kubernetes.

-	They are created and destroyed dynamically hence thier IP address will change frequently.

-	Service has permanant IP address which accept the incoming traffic and redirect it to pods.

-	Service can show different behavior and perform different activities based on the service type specified at the time of deployment.

	syntax:
	
	#kubectl expose deployment [name] --type=[type] --port=[port]
	
	example:
	
	#kubectl expose deployment my-app --type=LoadBalancer --port=8080

What are events in kubernetes?

-	Whenver an deployment, pod, replicaset and service is created or updated or deleted these actions are called as events.

-	To view all events that were generated in kubernetes we need to use the following command.

	example:
	
	#kubectl get events
	
-	We can also sort the events by timestamp of their occurence using the following command.

	example:
	
	#kubectl get events --sort-by=.metadata.creationTimestamp
	
What are different components of master node?

-	The master node has four components called as distributed database, api-server, scheduler and controller manager.

-	The distributed database is called etcd.

-	All kubernetes desired state i.e. commands executed to change the state of cluster are stored in etcd.

-	The api-server is called as kube api-server.

-	It is an interface between the cloud shell window and kubernetes engine.

-	The scheduler is called kube scheduler.

-	It is responsible to make decision on which node new pod will be created.

-	The controller manager is alse called as kube controller manager.

-	It is responsible to monitor the health of the cluster.

-	It ensures that actual state of kubernetes cluster matches desired state from distributed database.

What are different components of worker node?

-	The worker node has four components called as node agent, networking component, container runtime and pods.

-	The node agent is called kubelet.

-	It monitors the node and send information to controller manager of master node.

-	One of its activities is to monitor running pods and inform the controller manager of master node when a pod becomes unavailable.

-	The networking component is called kube proxy.

-	It helps in creating services i.e permanant interface around pods.

-	The container runtime is docker container which run inside a pod.

-	The worker node can contain one or more pods.

-	Applications run inside pods.

How to deploy microservices in kubernetes?

-	Kubernetes provides service discovery, api gateway and log management features.	

-	Therefore we need to remove the following dependencies from maven pom.xml of the microservices project.

	example:
	
	<!-- naming server-->
	<dependency>
		<groupId>org.springframework.cloud</groupId>
		<artifactId>spring-cloud-starter-netflix-eureka-server</artifactId>
	</dependency>
	
	<!-- naming client-->
	<dependency>
		<groupId>org.springframework.cloud</groupId>
		<artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
	</dependency>
	
	<!-- api gateway-->
	<dependency>
		<groupId>org.springframework.cloud</groupId>
		<artifactId>spring-cloud-starter-netflix-zuul</artifactId>
	</dependency>
	
	<!-- zipkin -->
	<dependency>
		<groupId>org.springframework.cloud</groupId>
		<artifactId>spring-cloud-sleuth-zipkin</artifactId>
	</dependency>
	
	<!-- rabbit mq-->
	<dependency>
		<groupId>org.springframework.ampq</groupId>
		<artifactId>spring-rabbit</artifactId>
	</dependency>
	
-	By default kubernetes will create environment variable for each microservice at time of deployment.

-	The value of this variable will be instance information of pod running docker container for microservice.

-	When microservice name is my-app-ms1 then kubernetes will create environment variable with name MY_APP_MS1_SERVICE_HOST.

-	Next step we need to update annotation of feign proxy to use kubernetes created environment variable.

	example:
	
	@FeignClient(name = "my-app-ms1", url = "${MY_APP_MS1_SERVICE_HOST}:8080")

How to use yaml configuration to deploy microservices in kubernetes?

-	Deployment in kubernetes using yaml file is called declarative approach.

-	Copy the yaml file of existing deployment using the below command.

	syntax:
	
	#kubectl get deployment [name] -o yaml >> [file]
	
	example:
	
	#kubectl get deployment my-app-ms1 -o yaml >> deployment.yaml
	
-	Copy the yaml file of existing service using the below command.

	syntax:
	
	#kubectl get service [deployment name] -o yaml >> [file]
	
	example:
	
	#kubectl get service my-app-ms1 -o yaml >> service.yaml
	
-	Append the contents of service.yaml to the contents of deployment.yaml.	

-	Update deployment.yaml as required.

-	Delete the existing deployment of the microservice using the following command.

	syntax:
	
	#kubectl delete all -l [label]=[value]
	
	example:
	
	#kubectl delete all -ll app=my-app-ms1
	
-	Deleting deployment is optional otherwise kubernetes will update existing deployment.	

-	Create or update the existing deployment using following command.

	syntax:
	
	#kubectl apply -f [file]
	
	example:
	
	#kubectl apply -f deployment.yaml
	
Why is it recommended to not use kubernetes created environment variable?

-	The kubernetes will create environment variable for each microservice. 

-	Consider a situation where we have two microservices my-app-ms1 and my-app-ms2.

-	The microservice my-app-ms1 makes a web request to my-app-ms2.

-	However while deployment the my-app-ms1 is deployed first an hence there is no environment variable of my-app-ms2.

-	Even when later my-app-ms2 is deployed the environment variable is not made available to my-app-ms1.

-	When microservice my-app-ms1 will call my-app-ms2 the web request will fail with runtime exception.

-	Hence it is recommended to use custom environment variable instead of kubernetes created environment variable.

-	We can pass this environment variable to container of my-app-ms1 microservice in deployment.yaml.

	syntax:
	
	env:
		-name: [name]
		 value: http://[permanant service]

	example:
	
	env:
		-name: MY_APP_MS1_URI
		 value: http://my-app-ms1 
 	
